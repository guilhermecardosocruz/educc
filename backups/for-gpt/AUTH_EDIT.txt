
===== components/LoginCard.tsx =====
1 "use client";
2 import { useState } from "react";
3 import Link from "next/link";
4 import { useRouter } from "next/navigation";
5 
6 export default function LoginCard() {
7   const router = useRouter();
8   const [emailOrCpf, setEmailOrCpf] = useState("");
9   const [password, setPassword] = useState("");
10   const [loading, setLoading] = useState(false);
11   const [err, setErr] = useState<string | null>(null);
12 
13   async function onSubmit(e: React.FormEvent) {
14     e.preventDefault();
15     setLoading(true);
16     setErr(null);
17     try {
18       const res = await fetch("/api/auth/login", {
19         method: "POST",
20         headers: { "content-type": "application/json" },
21         body: JSON.stringify({ emailOrCpf, password })
22       });
23       const data = await res.json().catch(()=> ({}));
24       if (!res.ok || !data?.ok) {
25         setErr(data?.error ?? "Credenciais inválidas");
26       } else {
27         router.push("/dashboard");
28       }
29     } catch {
30       setErr("Falha de rede. Tente novamente.");
31     } finally {
32       setLoading(false);
33     }
34   }
35 
36   return (
37     <div className="card p-8 max-w-md w-full">
38       <div className="flex items-center justify-between mb-6">
39         <div className="flex items-center gap-3">
40           <span className="inline-block h-4 w-4 rounded-full bg-[var(--color-brand-blue)]" />
41           <span className="font-semibold">EDUCC</span>
42         </div>
43         <Link href="/recover-email" className="text-sm text-[var(--color-brand-blue)] hover:underline">
44           Esqueci minha senha
45         </Link>
46       </div>
47 
48       <h1 className="text-2xl font-semibold mb-1">Entrar</h1>
49       <p className="text-sm text-gray-500 mb-6">Acesse sua conta</p>
50 
51       <form onSubmit={onSubmit} className="space-y-4">
52         <div>
53           <label className="block text-sm mb-1">E-mail ou CPF</label>
54           <input
55             className="input"
56             type="text"
57             placeholder="voce@exemplo.com ou 000.000.000-00"
58             value={emailOrCpf}
59             onChange={(e) => setEmailOrCpf(e.target.value)}
60             required
61           />
62         </div>
63 
64         <div>
65           <label className="block text-sm mb-1">Senha</label>
66           <input
67             className="input"
68             type="password"
69             placeholder="Sua senha"
70             value={password}
71             onChange={(e) => setPassword(e.target.value)}
72             required
73             minLength={8}
74             autoComplete="current-password"
75           />
76         </div>
77 
78         {err && <p className="text-sm text-red-600">{err}</p>}
79 
80         <button type="submit" className="btn-primary w-full" disabled={loading}>
81           {loading ? "Entrando..." : "Entrar"}
82         </button>
83       </form>
84 
85       <p className="text-sm text-gray-600 mt-6">
86         Não tem conta?{" "}
87         <Link href="/register" className="text-[var(--color-brand-blue)] hover:underline">
88           Criar conta
89         </Link>
90       </p>
91     </div>
92   );
93 }

===== app/(auth)/login/page.tsx =====
1 import LoginCard from "@/components/LoginCard";
2 
3 export default function LoginPage() {
4   return (
5     <main className="min-h-screen flex items-center justify-center p-6 bg-white">
6       <LoginCard />
7     </main>
8   );
9 }

===== app/(auth)/register/page.tsx =====
1 "use client";
2 import { useState } from "react";
3 import Link from "next/link";
4 import { useRouter } from "next/navigation";
5 
6 // Helpers de máscara
7 function onlyDigits(s: string) { return s.replace(/\D+/g, ""); }
8 
9 function maskCPF(v: string) {
10   const d = onlyDigits(v).slice(0, 11);
11   const p1 = d.slice(0,3);
12   const p2 = d.slice(3,6);
13   const p3 = d.slice(6,9);
14   const p4 = d.slice(9,11);
15   let out = p1;
16   if (p2) out += "." + p2;
17   if (p3) out += "." + p3;
18   if (p4) out += "-" + p4;
19   return out;
20 }
21 
22 function maskPhoneBR(v: string) {
23   const d = onlyDigits(v).slice(0, 11);
24   const ddd = d.slice(0,2);
25   const a = d.length > 10 ? d.slice(2,7) : d.slice(2,6);
26   const b = d.length > 10 ? d.slice(7,11) : d.slice(6,10);
27   let out = ddd ? `(${ddd}` : "";
28   if (ddd && d.length >= 2) out += ") ";
29   if (a) out += a;
30   if (b) out += "-" + b;
31   return out;
32 }
33 
34 export default function RegisterPage() {
35   const router = useRouter();
36   const [form, setForm] = useState({
37     name: "",
38     cpf: "",
39     birthDate: "",
40     email: "",
41     phone: "",
42     password: "",
43     confirmPassword: ""
44   });
45   const [loading, setLoading] = useState(false);
46   const [err, setErr] = useState<string | null>(null);
47 
48   function update<K extends keyof typeof form>(k: K, v: string) {
49     setForm((f) => ({ ...f, [k]: v }));
50   }
51 
52   async function onSubmit(e: React.FormEvent) {
53     e.preventDefault();
54     setLoading(true);
55     setErr(null);
56 
57     // normalizações
58     const email = form.email.trim().toLowerCase();
59     const cpf = form.cpf.trim();
60     const phone = form.phone.trim();
61     const name = form.name.trim();
62 
63     if (form.password.length < 8) {
64       setErr("A senha deve ter pelo menos 8 caracteres");
65       setLoading(false);
66       return;
67     }
68     if (form.password !== form.confirmPassword) {
69       setErr("As senhas não conferem");
70       setLoading(false);
71       return;
72     }
73     // Validações básicas de client
74     if (onlyDigits(cpf).length !== 11) {
75       setErr("CPF inválido");
76       setLoading(false);
77       return;
78     }
79     const phoneDigits = onlyDigits(phone);
80     if (!(phoneDigits.length === 10 || phoneDigits.length === 11)) {
81       setErr("Telefone inválido");
82       setLoading(false);
83       return;
84     }
85     if (!form.birthDate) {
86       setErr("Informe a data de nascimento");
87       setLoading(false);
88       return;
89     }
90 
91     try {
92       const res = await fetch("/api/auth/register", {
93         method: "POST",
94         headers: { "content-type": "application/json" },
95         body: JSON.stringify({
96           ...form,
97           name,
98           cpf,        // API já remove dígitos; máscara ok
99           phone,      // idem
100           email       // normalizado
101         })
102       });
103       const data = await res.json().catch(()=> ({}));
104       if (!res.ok || !data?.ok) {
105         setErr(data?.error ?? "Erro ao criar conta");
106       } else {
107         router.push("/login");
108       }
109     } catch {
110       setErr("Falha de rede. Tente novamente.");
111     } finally {
112       setLoading(false);
113     }
114   }
115 
116   return (
117     <main className="min-h-screen grid grid-cols-1 lg:grid-cols-2">
118       <section className="hidden lg:flex items-center justify-center bg-[var(--color-brand-blue)] text-white">
119         <div className="max-w-xl px-8">
120           <h2 className="text-4xl font-extrabold leading-tight">
121             Crie sua conta EDUCC
122           </h2>
123           <p className="mt-4 text-white/90">
124             Acesso rápido e seguro.
125           </p>
126         </div>
127       </section>
128 
129       <section className="flex items-center justify-center p-6 lg:p-12">
130         <div className="card p-8 max-w-lg w-full">
131           <div className="flex items-center justify-between mb-6">
132             <div className="flex items-center gap-3">
133               <span className="inline-block h-4 w-4 rounded-full bg-[var(--color-brand-blue)]" />
134               <span className="font-semibold">EDUCC</span>
135             </div>
136             <Link href="/login" className="text-sm text-[var(--color-brand-blue)] hover:underline">
137               Já tenho conta
138             </Link>
139           </div>
140 
141           <h1 className="text-2xl font-semibold mb-1">Criar conta</h1>
142           <p className="text-sm text-gray-500 mb-6">Preencha seus dados</p>
143 
144           <form onSubmit={onSubmit} className="grid grid-cols-1 sm:grid-cols-2 gap-4">
145             <div className="sm:col-span-2">
146               <label className="block text-sm mb-1">Nome completo</label>
147               <input
148                 className="input"
149                 value={form.name}
150                 onChange={e=>update("name", e.target.value)}
151                 required
152                 autoComplete="name"
153               />
154             </div>
155 
156             <div>
157               <label className="block text-sm mb-1">CPF</label>
158               <input
159                 className="input"
160                 inputMode="numeric"
161                 placeholder="000.000.000-00"
162                 value={form.cpf}
163                 onChange={(e)=> update("cpf", maskCPF(e.target.value))}
164                 maxLength={14}                             
165                 required
166                 pattern="^\d{3}\.\d{3}\.\d{3}-\d{2}$"
167                 title="Formato: 000.000.000-00"
168                 autoComplete="off"
169               />
170             </div>
171 
172             <div>
173               <label className="block text-sm mb-1">Data de nascimento</label>
174               <input
175                 className="input"
176                 type="date"
177                 value={form.birthDate}
178                 onChange={e=>update("birthDate", e.target.value)}
179                 required
180                 autoComplete="bday"
181               />
182             </div>
183 
184             <div>
185               <label className="block text-sm mb-1">E-mail</label>
186               <input
187                 className="input"
188                 type="email"
189                 placeholder="voce@exemplo.com"
190                 value={form.email}
191                 onChange={(e)=> update("email", e.target.value.trim())}
192                 required
193                 autoComplete="email"
194               />
195             </div>
196 
197             <div>
198               <label className="block text-sm mb-1">Telefone (Whats)</label>
199               <input
200                 className="input"
201                 type="tel"
202                 inputMode="tel"
203                 placeholder="(00) 00000-0000"
204                 value={form.phone}
205                 onChange={(e)=> update("phone", maskPhoneBR(e.target.value))}
206                 maxLength={15}
207                 required
208                 pattern="^\(\d{2}\)\s?\d{4,5}-\d{4}$"
209                 title="Formato: (00) 00000-0000"
210                 autoComplete="tel"
211               />
212             </div>
213 
214             <div>
215               <label className="block text-sm mb-1">Senha</label>
216               <input
217                 className="input"
218                 type="password"
219                 value={form.password}
220                 onChange={e=>update("password", e.target.value)}
221                 required
222                 minLength={8}
223                 autoComplete="new-password"
224               />
225             </div>
226 
227             <div>
228               <label className="block text-sm mb-1">Confirmar senha</label>
229               <input
230                 className="input"
231                 type="password"
232                 value={form.confirmPassword}
233                 onChange={e=>update("confirmPassword", e.target.value)}
234                 required
235                 minLength={8}
236                 autoComplete="new-password"
237               />
238             </div>
239 
240             {err && <p className="sm:col-span-2 text-sm text-red-600">{err}</p>}
241 
242             <div className="sm:col-span-2">
243               <button type="submit" className="btn-primary w-full" disabled={loading}>
244                 {loading ? "Criando..." : "Criar conta"}
245               </button>
246             </div>
247           </form>
248         </div>
249       </section>
250     </main>
251   );
252 }

===== app/(auth)/recover/page.tsx =====
1 import { redirect } from "next/navigation";
2 
3 export default function Page() {
4   // redireciona imediatamente
5   redirect("/recover-email");
6 }

===== app/(auth)/recover-email/page.tsx =====
1 "use client";
2 import { useState } from "react";
3 import Link from "next/link";
4 
5 export default function RecoverEmailPage() {
6   const [email, setEmail] = useState("");
7   const [loading, setLoading] = useState(false);
8   const [done, setDone] = useState(false);
9   const [err, setErr] = useState<string | null>(null);
10 
11   async function onSubmit(e: React.FormEvent) {
12     e.preventDefault();
13     setLoading(true);
14     setErr(null);
15     try {
16       const res = await fetch("/api/auth/recover-email", {
17         method: "POST",
18         headers: { "content-type": "application/json" },
19         body: JSON.stringify({ email })
20       });
21       await res.json().catch(()=> ({}));
22       setDone(true);
23     } catch {
24       setErr("Falha de rede. Tente novamente.");
25     } finally {
26       setLoading(false);
27     }
28   }
29 
30   return (
31     <main className="min-h-screen grid grid-cols-1 lg:grid-cols-2">
32       <section className="hidden lg:flex items-center justify-center bg-[var(--color-brand-blue)] text-white">
33         <div className="max-w-xl px-8">
34           <h2 className="text-4xl font-extrabold leading-tight">
35             Recuperar conta por e-mail
36           </h2>
37           <p className="mt-4 text-white/90">
38             Enviaremos um link de recuperação ao seu e-mail.
39           </p>
40         </div>
41       </section>
42 
43       <section className="flex items-center justify-center p-6 lg:p-12">
44         <div className="card p-8 max-w-md w-full">
45           <div className="flex items-center justify-between mb-6">
46             <div className="flex items-center gap-3">
47               <span className="inline-block h-4 w-4 rounded-full bg-[var(--color-brand-blue)]" />
48               <span className="font-semibold">EDUCC</span>
49             </div>
50             <Link href="/login" className="text-sm text-[var(--color-brand-blue)] hover:underline">
51               Voltar ao login
52             </Link>
53           </div>
54 
55           <h1 className="text-2xl font-semibold mb-1">Recuperar por e-mail</h1>
56           <p className="text-sm text-gray-500 mb-6">Informe o e-mail cadastrado</p>
57 
58           {done ? (
59             <div className="space-y-3">
60               <p className="text-green-700">
61                 Se o e-mail existir, enviamos um link de recuperação. Verifique sua caixa de entrada.
62               </p>
63               <Link href="/login" className="btn-primary inline-flex justify-center">Voltar ao login</Link>
64             </div>
65           ) : (
66             <form onSubmit={onSubmit} className="space-y-4">
67               <div>
68                 <label className="block text-sm mb-1">E-mail</label>
69                 <input
70                     className="input"
71                     type="email"
72                     placeholder="voce@exemplo.com"
73                     value={email}
74                     onChange={(e) => setEmail(e.target.value)}
75                     required
76                     autoComplete="email"
77                 />
78               </div>
79 
80               {err && <p className="text-sm text-red-600">{err}</p>}
81 
82               <button type="submit" className="btn-primary w-full" disabled={loading}>
83                 {loading ? "Enviando..." : "Enviar link"}
84               </button>
85             </form>
86           )}
87         </div>
88       </section>
89     </main>
90   );
91 }

===== app/api/auth/login/route.ts =====
1 import { NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { z } from "zod";
4 import bcrypt from "bcryptjs";
5 import { cookies } from "next/headers";
6 
7 const schema = z.object({
8   emailOrCpf: z.string().min(3),
9   password: z.string().min(8)
10 });
11 
12 const COOKIE_NAME = "session_user_id";
13 
14 function onlyDigits(s: string){ return s.replace(/\D+/g, ""); }
15 
16 export async function POST(req: Request) {
17   try {
18     const body = await req.json().catch(() => ({}));
19     const parsed = schema.safeParse(body);
20     if (!parsed.success) {
21       return NextResponse.json({ ok:false, error: parsed.error.flatten() }, { status: 400 });
22     }
23     const { emailOrCpf, password } = parsed.data;
24 
25     const byEmail = emailOrCpf.includes("@");
26     const where = byEmail
27       ? { email: emailOrCpf.toLowerCase() }
28       : { cpf: onlyDigits(emailOrCpf) };
29 
30     const user = await prisma.user.findUnique({
31       where,
32       select: { id: true, name: true, email: true, passwordHash: true }
33     });
34 
35     // resposta genérica para não dar dica
36     const invalid = NextResponse.json({ ok:false, error: "Credenciais inválidas" }, { status: 401 });
37 
38     if (!user || !user.passwordHash) return invalid;
39 
40     const ok = await bcrypt.compare(password, user.passwordHash);
41     if (!ok) return invalid;
42 
43     const c = await cookies();
44     // cookie simples; se quiser, migramos para JWT com expiração/refresh
45     c.set({
46       name: COOKIE_NAME,
47       value: user.id,
48       httpOnly: true,
49       path: "/",
50       sameSite: "lax",
51       // sem maxAge => cookie de sessão; podemos colocar expiração se preferir
52     });
53 
54     return NextResponse.json({ ok:true, user: { id: user.id, name: user.name, email: user.email } });
55   } catch (err:any) {
56     return NextResponse.json({ ok:false, error: err?.message ?? "Erro" }, { status: 500 });
57   }
58 }

===== app/api/auth/register/route.ts =====
1 import { NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { z } from "zod";
4 import bcrypt from "bcryptjs";
5 
6 const schema = z.object({
7   name: z.string().min(2),
8   cpf: z.string().min(11),
9   birthDate: z.string(), // ISO yyyy-mm-dd
10   email: z.string().email(),
11   phone: z.string().min(8),
12   password: z.string().min(8, "A senha deve ter pelo menos 8 caracteres"),
13   confirmPassword: z.string().min(8)
14 }).refine((d) => d.password === d.confirmPassword, {
15   message: "As senhas não conferem",
16   path: ["confirmPassword"]
17 });
18 
19 function onlyDigits(s: string){ return s.replace(/\D+/g, ""); }
20 
21 export async function POST(req: Request) {
22   try {
23     const body = await req.json().catch(() => ({}));
24     const parsed = schema.safeParse(body);
25     if (!parsed.success) {
26       return NextResponse.json({ ok:false, error: parsed.error.flatten() }, { status: 400 });
27     }
28     const { name, cpf, birthDate, email, phone, password } = parsed.data;
29 
30     const exists = await prisma.user.findFirst({
31       where: { OR: [{ email: email.toLowerCase() }, { cpf: onlyDigits(cpf) }] },
32       select: { id: true }
33     });
34     if (exists) {
35       return NextResponse.json({ ok:false, error: "E-mail ou CPF já cadastrado" }, { status: 409 });
36     }
37 
38     const passwordHash = await bcrypt.hash(password, 10);
39 
40     const user = await prisma.user.create({
41       data: {
42         name,
43         cpf: onlyDigits(cpf),
44         birthDate: new Date(birthDate),
45         email: email.toLowerCase(),
46         phone: onlyDigits(phone),
47         passwordHash
48       },
49       select: { id: true, name: true, email: true }
50     });
51 
52     // (opcional) já poderíamos criar sessão aqui — vou deixar a autenticação no /login
53     return NextResponse.json({ ok:true, user }, { status: 201 });
54   } catch (err:any) {
55     return NextResponse.json({ ok:false, error: err?.message ?? "Erro" }, { status: 500 });
56   }
57 }

===== app/api/auth/recover-email/route.ts =====
1 import { NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { z } from "zod";
4 import crypto from "node:crypto";
5 import { sendRecoveryEmail } from "@/lib/email";
6 
7 const schema = z.object({ email: z.string().email() });
8 
9 export async function POST(req: Request) {
10   try {
11     const body = await req.json().catch(()=> ({}));
12     const parsed = schema.safeParse(body);
13     if (!parsed.success) {
14       return NextResponse.json({ ok:false, error: parsed.error.flatten() }, { status: 400 });
15     }
16 
17     const email = parsed.data.email.toLowerCase();
18     const user = await prisma.user.findUnique({
19       where: { email },
20       select: { id: true, name: true }
21     });
22 
23     // Não expomos existência do e-mail; mas só criamos token se existir.
24     if (user) {
25       const token = crypto.randomBytes(32).toString("hex");
26       const expires = new Date(Date.now() + 1000 * 60 * 10); // 10 minutos
27 
28       await prisma.passwordResetToken.create({
29         data: { token, userId: user.id, expiresAt: expires }
30       });
31 
32       const base = process.env.APP_BASE_URL ?? "http://localhost:3000";
33       const link = `${base}/reset/${token}`;
34 
35       const firstName = (user.name || "").split(" ")[0] || "Olá";
36       const subject = "Recuperação de conta • EDUCC";
37       const text =
38 `${firstName}, recebemos um pedido para recuperar sua conta EDUCC.
39 Abra este link em até 10 min: ${link}
40 
41 Se não foi você, ignore este e-mail.`;
42       const html =
43 `<p>${firstName}, recebemos um pedido para recuperar sua conta <b>EDUCC</b>.</p>
44 <p>Abra este link em até <b>10 min</b>: <a href="${link}">${link}</a></p>
45 <p>Se não foi você, ignore esta mensagem.</p>`;
46 
47       // Só envia se EMAIL_PROVIDER_ENABLED=true; senão, fica "no-op"
48       await sendRecoveryEmail(email, subject, text, html);
49     }
50 
51     // Sempre OK para não permitir enumeração de e-mails
52     return NextResponse.json({ ok: true }, { status: 200 });
53   } catch (err: any) {
54     return NextResponse.json({ ok:false, error: { message: err?.message ?? "Erro" } }, { status: 500 });
55   }
56 }

===== app/api/auth/me/route.ts =====
1 import { NextResponse } from "next/server";
2 import { requireUser } from "@/lib/session";
3 
4 export async function GET() {
5   const user = await requireUser();
6   if (!user) return NextResponse.json({ ok:false }, { status: 401 });
7   return NextResponse.json({ ok:true, user });
8 }

===== app/api/auth/logout/route.ts =====
1 import { NextResponse } from "next/server";
2 import { clearSessionCookie } from "@/lib/session";
3 
4 export async function POST() {
5   try {
6     await clearSessionCookie();
7     return NextResponse.json({ ok:true });
8   } catch {
9     return NextResponse.json({ ok:false }, { status: 500 });
10   }
11 }

===== lib/session.ts =====
1 import { cookies, headers } from "next/headers";
2 import { prisma } from "@/lib/prisma";
3 
4 const COOKIE_NAME = "session_user_id";
5 
6 /** Lê o userId do cookie (async em Next 15) */
7 export async function getSessionUserId(): Promise<string | null> {
8   try {
9     const c = await cookies();
10     const id = c.get(COOKIE_NAME)?.value || null;
11     return id;
12   } catch {
13     // Fallback para contexts onde cookies() não está disponível
14     const h = await headers();
15     const cookieHeader = h.get("cookie") || "";
16     const m = cookieHeader.match(new RegExp(`${COOKIE_NAME}=([^;]+)`));
17     return m ? m[1] : null;
18   }
19 }
20 
21 /** Busca o usuário logado; retorna null se não houver */
22 export async function requireUser() {
23   const id = await getSessionUserId();
24   if (!id) return null;
25   const user = await prisma.user.findUnique({
26     where: { id },
27     select: { id: true, name: true, email: true }
28   });
29   return user;
30 }
31 
32 /** Apaga o cookie de sessão (async em Next 15) */
33 export async function clearSessionCookie() {
34   const c = await cookies();
35   c.set({
36     name: COOKIE_NAME,
37     value: "",
38     httpOnly: true,
39     path: "/",
40     maxAge: 0
41   });
42 }

===== prisma/schema.prisma =====
1 generator client {
2   provider = "prisma-client-js"
3 }
4 
5 datasource db {
6   provider   = "postgresql"
7   url        = env("DATABASE_URL")
8   directUrl  = env("DIRECT_URL")
9 }
10 
11 model User {
12   id           String   @id @default(cuid())
13   name         String
14   cpf          String   @unique
15   birthDate    DateTime
16   email        String   @unique
17   phone        String
18   createdAt    DateTime @default(now())
19   passwordHash String?
20 
21   resetTokens PasswordResetToken[]
22   classes     Class[]            @relation("UserClasses")
23 }
24 
25 model PasswordResetToken {
26   id        String   @id @default(cuid())
27   token     String   @unique
28   userId    String
29   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
30   expiresAt DateTime
31   usedAt    DateTime?
32   createdAt DateTime @default(now())
33 }
34 
35 model Class {
36   id          String       @id @default(cuid())
37   name        String
38   ownerId     String
39   owner       User         @relation("UserClasses", fields: [ownerId], references: [id], onDelete: Cascade)
40   createdAt   DateTime     @default(now())
41 
42   attendances Attendance[]
43   contents    Content[]
44   students    Student[]
45 }
46 
47 model Attendance {
48   id        String   @id @default(cuid())
49   classId   String
50   cls       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
51   seq       Int
52   title     String   @default("Chamada")
53   createdAt DateTime @default(now())
54   lessonDate DateTime?   // data editável da aula (UTC, opcional)
55 
56   @@unique([classId, seq])
57 }
58 
59 model Content {
60   id        String   @id @default(cuid())
61   classId   String
62   cls       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
63   seq       Int
64   title     String   @default("Conteúdo")
65   bodyHtml  String?  // futuro: editor; por enquanto pode ficar vazio
66   createdAt DateTime @default(now())
67 
68   @@unique([classId, seq])
69 }
70 
71 model Student {
72   id        String   @id @default(cuid())
73   classId   String
74   cls       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
75   name      String
76   cpf       String?
77   contact   String?  // whatsapp/email/telefone
78   createdAt DateTime @default(now())
79 }
80 
81 
82 /// Marcações de presença por aluno em uma chamada específica (classId+seq).
83 
84 /// Marcações de presença por aluno em uma chamada específica (classId+seq).
85 model AttendancePresence {
86   id        String   @id @default(cuid())
87   classId   String
88   seq       Int
89   studentId String
90   present   Boolean  @default(false)
91   createdAt DateTime @default(now())
92   updatedAt DateTime @updatedAt
93 
94   // Sem relações Prisma para não exigir back-relations agora.
95   @@unique([classId, seq, studentId], name: "class_seq_student_unique")
96   @@index([classId, seq], name: "class_seq_idx")
97 }

===== middleware.ts =====
1 import { NextResponse } from "next/server";
2 import type { NextRequest } from "next/server";
3 
4 export function middleware(req: NextRequest) {
5   const path = req.nextUrl.pathname;
6 
7   // Corrige / (auth) /register e / (auth) /recover
8   if (path === "/(auth)/register") {
9     const url = req.nextUrl.clone();
10     url.pathname = "/register";
11     return NextResponse.redirect(url);
12   }
13   if (path === "/(auth)/recover") {
14     const url = req.nextUrl.clone();
15     url.pathname = "/recover-email";
16     return NextResponse.redirect(url);
17   }
18 
19   return NextResponse.next();
20 }
21 
22 export const config = {
23   matcher: ["/(auth)/register", "/(auth)/recover"]
24 };

===== lib/email.ts =====
1 /**
2  * Envio de e-mail desativado por padrão.
3  * Para ativar, configure:
4  *   - EMAIL_PROVIDER_ENABLED=true
5  *   - (exemplo com Resend) RESEND_API_KEY=...
6  *   - MAIL_FROM="EDUCC <no-reply@SEU-DOMINIO>"
7  */
8 export async function sendRecoveryEmail(to: string, subject: string, text: string, html?: string) {
9   const enabled = process.env.EMAIL_PROVIDER_ENABLED === "true";
10   if (!enabled) {
11     // Modo silencioso: não envia nada enquanto você não tiver domínio/provedor
12     return { sent: false, reason: "Email provider disabled" };
13   }
14 
15   // EXEMPLO com Resend (quando você tiver domínio e chave):
16   const apiKey = process.env.RESEND_API_KEY;
17   const from = process.env.MAIL_FROM || "no-reply@example.com";
18   if (!apiKey) throw new Error("RESEND_API_KEY missing");
19   const res = await fetch("https://api.resend.com/emails", {
20     method: "POST",
21     headers: {
22       "Authorization": `Bearer ${apiKey}`,
23       "Content-Type": "application/json"
24     },
25     body: JSON.stringify({ from, to, subject, text, html })
26   });
27   if (!res.ok) {
28     const body = await res.text().catch(()=>"");
29     throw new Error(`Email API error ${res.status}: ${body}`);
30   }
31   return { sent: true };
32 }
