import { NextResponse } from "next/server";
import { PDFDocument, StandardFonts, rgb, PDFFont } from "pdf-lib";
import QRCode from "qrcode";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

type EventPayload = {
  id: string;
  nome: string;
  descricao?: string;
  data_inicio?: string;  // "YYYY-MM-DD"
  data_fim?: string;     // "YYYY-MM-DD"
  local?: string;
  cidade_uf?: string;
  carga_horaria?: string;
  responsavel?: string;
  // textos
  texto_participante?: string;
  texto_ministrante?: string;
  texto_organizador?: string;
  texto_verso?: string;        // conteúdo programático (pode vir com ';' separando itens)
  // assinaturas configuráveis
  sign1_name?: string; sign1_role?: string;
  sign2_name?: string; sign2_role?: string;
  // validação & autorização (verso)
  qr_url?: string;
  autorizacao_texto?: string;
};

type Student = {
  aluno_nome: string;
  aluno_doc?: string;
  turma?: string;
  carga_horaria?: string;
  observacoes?: string;
};

/* ============================== Helpers ============================== */
function wrapTextByWidth({ text, font, size, maxWidth }: { text: string; font: PDFFont; size: number; maxWidth: number }): string[] {
  const words = (text || "").trim().split(/\s+/);
  const lines: string[] = [];
  let line = "";
  for (const w of words) {
    const t = line ? line + " " + w : w;
    if (font.widthOfTextAtSize(t, size) <= maxWidth) {
      line = t;
    } else {
      if (line) lines.push(line);
      // quebra palavra longa
      if (font.widthOfTextAtSize(w, size) > maxWidth) {
        let chunk = "";
        for (const ch of w) {
          const t2 = chunk + ch;
          if (font.widthOfTextAtSize(t2, size) <= maxWidth) chunk = t2;
          else { if (chunk) lines.push(chunk); chunk = ch; }
        }
        line = chunk;
      } else {
        line = w;
      }
    }
  }
  if (line) lines.push(line);
  return lines;
}
function drawCenteredText(page: any, text: string, y: number, size: number, font: PDFFont, color = rgb(0,0,0), characterSpacing?: number) {
  const { width } = page.getSize();
  const textWidth = font.widthOfTextAtSize(text, size) + (characterSpacing ? characterSpacing * text.length : 0);
  page.drawText(text, { x: (width - textWidth) / 2, y, size, font, color, characterSpacing });
}
function drawRightAlignedText(page: any, text: string, y: number, size: number, font: PDFFont, rightMargin: number, color = rgb(0,0,0)) {
  const { width } = page.getSize();
  const textWidth = font.widthOfTextAtSize(text, size);
  page.drawText(text, { x: Math.max(0, width - rightMargin - textWidth), y, size, font, color });
}
function formatBR(iso?: string | null): string | null {
  if (!iso) return null;
  const d = new Date(iso);
  if (isNaN(d.getTime())) return iso;
  const dd = String(d.getDate()).padStart(2, "0");
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const yyyy = d.getFullYear();
  return `${dd}/${mm}/${yyyy}`;
}

/* ============================== PDF builder ============================== */
async function buildCertificatesPDF(ev: EventPayload, alunos: Student[]): Promise<Uint8Array> {
  const pdf = await PDFDocument.create();
  // Tipografia: Times (mais próxima do modelo)
  const font = await pdf.embedFont(StandardFonts.TimesRoman);
  const fontBold = await pdf.embedFont(StandardFonts.TimesBold);
  const fontItalic = await pdf.embedFont(StandardFonts.TimesItalic);

  // Paleta
  const red = rgb(0.80, 0.00, 0.00);
  const green = rgb(0.00, 0.45, 0.30);
  const gray = rgb(0.25, 0.25, 0.25);

  // Assinaturas fallback
  const s1name = (ev.sign1_name || "VÁGNER ESPÍNDOLA RODRIGUES").toUpperCase();
  const s1role = ev.sign1_role || "Prefeito Municipal";
  const s2name = (ev.sign2_name || "GEÓVANA BENEDET ZANETTE").toUpperCase();
  const s2role = ev.sign2_role || "Secretária Municipal de Educação";

  for (const st of alunos) {
    if (!st?.aluno_nome) continue;

    /* =============================== FRENTE =============================== */
    const page = pdf.addPage([842, 595]); // A4 paisagem
    const { width, height } = page.getSize();
    const margin = 36, left = margin, right = margin;

    // Moldura
    page.drawRectangle({ x: margin / 2, y: margin / 2, width: width - margin, height: height - margin, borderColor: rgb(0.75,0.75,0.75), borderWidth: 0.8 });

    // Barras decorativas
    page.drawRectangle({ x: width - 150, y: height - 48, width: 150, height: 48, color: red });
    page.drawRectangle({ x: width - 105, y: height - 80, width: 105, height: 32, color: green });

    // Título com tracking maior
    let yTopTitle = height - 104;
    drawCenteredText(page, "CERTIFICADO", yTopTitle, 32, fontBold, red, 2.5);

    // Nome + documento centralizado (negrito)
    let yName = yTopTitle - 42;
    const nameLine = [st.aluno_nome.toUpperCase(), st.aluno_doc ? `- ${st.aluno_doc}` : ""].filter(Boolean).join(" ");
    drawCenteredText(page, nameLine, yName, 15, fontBold);

    // Área disponível para centralização vertical do corpo:
    const topLimit = yName - 24;      // limite superior (logo abaixo do nome)
    const bottomLimit = 120;          // limite inferior (acima das assinaturas)
    const usableHeight = topLimit - bottomLimit;

    // Corpo do texto
    const inicioBR = formatBR(ev.data_inicio);
    const fimBR = formatBR(ev.data_fim);
    const periodo = (inicioBR || fimBR) ? `${inicioBR ?? ""}${inicioBR && fimBR ? " a " : ""}${fimBR ?? ""}` : "";
    const carga = st.carga_horaria || ev.carga_horaria || "";

    let paragraph = ev.texto_participante?.trim();
    if (paragraph) {
      paragraph = paragraph
        .replace(/\[nome do participante\]/gi, st.aluno_nome)
        .replace(/\[cpf\]/gi, st.aluno_doc || "")
        .replace(/\[carga horária\]/gi, carga);
    } else {
      const partes: string[] = [];
      partes.push(`Certificamos que ${st.aluno_nome} participou do Curso "${(ev.nome || "Curso").toUpperCase()}",`);
      partes.push("promovido e organizado pela Escola Municipal de Governo de Criciúma,");
      if (periodo) partes.push(`realizado no período de ${periodo},`);
      if (carga)  partes.push(`com carga horária de ${carga}.`);
      paragraph = partes.join(" ");
    }

    const contentX = left + 28;
    const contentWidth = width - (contentX + right + 28);
    const bodySize = 12.5, bodyLH = 17;
    const bodyLines = wrapTextByWidth({ text: paragraph, font, size: bodySize, maxWidth: contentWidth });

    // Centralização vertical: começamos de modo que o bloco inteiro fique no meio da área útil
    const totalBodyHeight = bodyLines.length * bodyLH;
    let y = topLimit - (usableHeight - totalBodyHeight) / 2;

    // Desenho centralizado (horizontal) linha a linha
    for (const line of bodyLines) {
      const w = font.widthOfTextAtSize(line, bodySize);
      const x = (width - w) / 2;
      page.drawText(line, { x, y, size: bodySize, font });
      y -= bodyLH;
    }

    // Data/Lugar (direita, cinza)
    const dataFormatada = formatBR(ev.data_fim || ev.data_inicio);
    const cidade = ev.cidade_uf?.trim() || ev.local?.trim();
    const linhaData = (cidade && dataFormatada) ? `${cidade}, ${dataFormatada}.` : (dataFormatada ? `${dataFormatada}.` : "");
    if (linhaData) drawRightAlignedText(page, linhaData, bottomLimit + 14 + bodyLH, 12, font, right, gray);

    // Assinaturas no rodapé
    const lineY = 86;
    const signCols = [
      { name: s1name, role: s1role },
      { name: s2name, role: s2role },
      { name: (st.aluno_nome || "Participante").toUpperCase(), role: "Participante" },
    ];
    const usableWidth = width - left - right;
    const colW = usableWidth / signCols.length;
    for (let i = 0; i < signCols.length; i++) {
      const x0 = left + i * colW + 16;
      const x1 = left + (i + 1) * colW - 16;
      page.drawLine({ start: { x: x0, y: lineY }, end: { x: x1, y: lineY }, thickness: 1, color: rgb(0,0,0) });
      const cx = (x0 + x1) / 2;
      const n = signCols[i].name;
      const r = signCols[i].role;
      const ns = 10.5, rs = 9.5;
      page.drawText(n, { x: cx - fontBold.widthOfTextAtSize(n, ns)/2, y: lineY - 15, size: ns, font: fontBold });
      page.drawText(r, { x: cx - font.widthOfTextAtSize(r, rs)/2, y: lineY - 30, size: rs, font });
    }

    /* =============================== VERSO =============================== */
    const page2 = pdf.addPage([842, 595]);
    const { width: w2, height: h2 } = page2.getSize();
    const m2 = 36, left2 = m2, right2 = m2;
    const contentX2 = left2 + 24;
    const contentW2 = w2 - (contentX2 + right2 + 24);

    // Moldura
    page2.drawRectangle({ x: m2 / 2, y: m2 / 2, width: w2 - m2, height: h2 - m2, borderColor: rgb(0.85,0.85,0.85), borderWidth: 0.8 });

    // Área superior (conteúdos)
    let y2 = h2 - 82;

    // Título "Conteúdo Programático:" e itens em lista (split por ';')
    if (ev.texto_verso && ev.texto_verso.trim()) {
      page2.drawText("Conteúdo Programático:", { x: contentX2, y: y2, size: 12.5, font: fontBold });
      y2 -= 18;

      const raw = ev.texto_verso.replace(/\s*;\s*$/,"");
      const items = raw.split(";").map(s => s.trim()).filter(Boolean);
      for (const item of items) {
        const line = `• ${item}${item.endsWith(".") ? "" : ";"}`;
        const lines = wrapTextByWidth({ text: line, font, size: 12, maxWidth: contentW2 });
        for (const ln of lines) {
          page2.drawText(ln, { x: contentX2, y: y2, size: 12, font });
          y2 -= 16;
        }
      }
    }

    // QR no canto inferior esquerdo
    const qrSize = 120;
    const qrX = left2 + 10;
    const qrY = m2 + 18;
    if (ev.qr_url && ev.qr_url.trim()) {
      const qrPng = await QRCode.toBuffer(ev.qr_url.trim(), { type: "png", width: qrSize, margin: 1 });
      const qrImg = await pdf.embedPng(qrPng);
      page2.drawRectangle({ x: qrX - 6, y: qrY - 6, width: qrSize + 12, height: qrSize + 12, borderColor: red, borderWidth: 1.2 });
      page2.drawImage(qrImg, { x: qrX, y: qrY, width: qrSize, height: qrSize });
    }

    // Rodapé (à direita)
    const footerBaseY = m2 + 40;  // “Curso autorizado...” nesta linha
    const totalY = footerBaseY + 16;  // TOTAL uma linha acima
    const rightMargin = right2;

    // TOTAL à direita (negrito)
    const totalCarga = (st.carga_horaria || ev.carga_horaria || "").trim();
    if (totalCarga) {
      drawRightAlignedText(page2, `TOTAL: ${totalCarga}`, totalY, 12.5, fontBold, rightMargin);
    }

    // Curso autorizado... (à direita)
    if (ev.autorizacao_texto && ev.autorizacao_texto.trim()) {
      drawRightAlignedText(page2, ev.autorizacao_texto.trim(), footerBaseY, 12, font, rightMargin);
    }

    // Responsável (linha abaixo, à direita)
    if (ev.responsavel && ev.responsavel.trim()) {
      drawRightAlignedText(page2, `Responsável: ${ev.responsavel.trim()}`, footerBaseY - 18, 12, font, rightMargin);
    }
  }

  return await pdf.save();
}

/* ============================== HTTP handler ============================== */
export async function POST(req: Request, { params }: { params: { id: string } }) {
  try {
    const body = await req.json().catch(() => ({}));
    const ev: EventPayload = body?.event;
    const alunos: Student[] = body?.students || [];

    if (!ev?.id || ev.id !== params.id) {
      return NextResponse.json({ ok: false, error: "Evento inválido" }, { status: 400 });
    }
    if (!ev?.nome) {
      return NextResponse.json({ ok: false, error: "Nome do evento é obrigatório" }, { status: 400 });
    }
    const validos = Array.isArray(alunos) ? alunos.filter((a) => a?.aluno_nome) : [];
    if (validos.length === 0) {
      return NextResponse.json({ ok: false, error: "Nenhum aluno válido fornecido" }, { status: 400 });
    }

    const pdfBytes = await buildCertificatesPDF(ev, validos);

    return new NextResponse(pdfBytes, {
      status: 200,
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="certificados-${params.id}.pdf"`,
        "Cache-Control": "no-store",
      },
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Falha ao gerar certificados" }, { status: 500 });
  }
}
