import { NextResponse } from "next/server";
import { PDFDocument, StandardFonts, rgb, PDFFont } from "pdf-lib";
import QRCode from "qrcode";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

type EventPayload = {
  id: string;
  nome: string;
  descricao?: string;
  data_inicio?: string;
  data_fim?: string;
  local?: string;
  cidade_uf?: string;
  carga_horaria?: string;
  responsavel?: string;
  // textos
  texto_participante?: string;
  texto_ministrante?: string;
  texto_organizador?: string;
  texto_verso?: string;
  // assinaturas configuráveis
  sign1_name?: string; sign1_role?: string;
  sign2_name?: string; sign2_role?: string;
  // validação & autorização
  qr_url?: string;
  autorizacao_texto?: string;
};

type Student = {
  aluno_nome: string;
  aluno_doc?: string;
  turma?: string;
  carga_horaria?: string;
  observacoes?: string;
};

/** Helpers -----------------------------------------------------------------------------------*/
function wrapTextByWidth({ text, font, size, maxWidth }: { text: string; font: PDFFont; size: number; maxWidth: number }): string[] {
  const words = (text || "").trim().split(/\s+/);
  const lines: string[] = [];
  let line = "";
  for (const w of words) {
    const t = line ? line + " " + w : w;
    if (font.widthOfTextAtSize(t, size) <= maxWidth) {
      line = t;
    } else {
      if (line) lines.push(line);
      // quebra palavra longa
      if (font.widthOfTextAtSize(w, size) > maxWidth) {
        let chunk = "";
        for (const ch of w) {
          const t2 = chunk + ch;
          if (font.widthOfTextAtSize(t2, size) <= maxWidth) chunk = t2;
          else { if (chunk) lines.push(chunk); chunk = ch; }
        }
        line = chunk;
      } else {
        line = w;
      }
    }
  }
  if (line) lines.push(line);
  return lines;
}
function drawCenteredText(page: any, text: string, y: number, size: number, font: PDFFont, color = rgb(0,0,0), characterSpacing?: number) {
  const { width } = page.getSize();
  const textWidth = font.widthOfTextAtSize(text, size) + (characterSpacing ? characterSpacing * text.length : 0);
  page.drawText(text, { x: (width - textWidth) / 2, y, size, font, color, characterSpacing });
}
function drawRightAlignedText(page: any, text: string, y: number, size: number, font: PDFFont, rightMargin: number, color = rgb(0,0,0)) {
  const { width } = page.getSize();
  const textWidth = font.widthOfTextAtSize(text, size);
  page.drawText(text, { x: Math.max(0, width - rightMargin - textWidth), y, size, font, color });
}
function formatBR(iso?: string | null): string | null {
  if (!iso) return null;
  const d = new Date(iso);
  if (isNaN(d.getTime())) return iso;
  const dd = String(d.getDate()).padStart(2, "0");
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const yyyy = d.getFullYear();
  return `${dd}/${mm}/${yyyy}`;
}
function drawSignaturesBlock(page: any, font: PDFFont, fontBold: PDFFont, opts: {
  y: number;
  leftMargin: number;
  rightMargin: number;
  titles: { name: string; role: string }[];
}) {
  const { width } = page.getSize();
  const { y, leftMargin, rightMargin, titles } = opts;
  const usableWidth = width - leftMargin - rightMargin;
  const cols = titles.length;
  const colW = usableWidth / cols;

  const lineY = y;
  const nameY = y - 15;
  const roleY = y - 30;

  for (let i = 0; i < cols; i++) {
    const padding = 16;
    const x0 = leftMargin + i * colW + padding;
    const x1 = leftMargin + (i + 1) * colW - padding;
    page.drawLine({ start: { x: x0, y: lineY }, end: { x: x1, y: lineY }, thickness: 1, color: rgb(0,0,0) });

    const centerX = (x0 + x1) / 2;
    const name = titles[i].name;
    const role = titles[i].role;

    const nameSize = 10.5;
    const roleSize = 9.5;
    const nameWidth = fontBold.widthOfTextAtSize(name, nameSize);
    const roleWidth = font.widthOfTextAtSize(role, roleSize);

    page.drawText(name, { x: centerX - nameWidth / 2, y: nameY, size: nameSize, font: fontBold });
    page.drawText(role, { x: centerX - roleWidth / 2, y: roleY, size: roleSize, font });
  }
}

/** Gerador -----------------------------------------------------------------------------------*/
async function buildCertificatesPDF(ev: EventPayload, alunos: Student[]): Promise<Uint8Array> {
  const pdf = await PDFDocument.create();
  const font = await pdf.embedFont(StandardFonts.Helvetica);
  const fontBold = await pdf.embedFont(StandardFonts.HelveticaBold);

  const red = rgb(0.80, 0.00, 0.00);
  const green = rgb(0.00, 0.45, 0.30);
  const gray = rgb(0.25, 0.25, 0.25);

  // Assinaturas padrão (fallback)
  const s1name = (ev.sign1_name || "VÁGNER ESPÍNDOLA RODRIGUES").toUpperCase();
  const s1role = ev.sign1_role || "Prefeito Municipal";
  const s2name = (ev.sign2_name || "GEÓVANA BENEDET ZANETTE").toUpperCase();
  const s2role = ev.sign2_role || "Secretária Municipal de Educação";

  for (const st of alunos) {
    if (!st?.aluno_nome) continue;

    /** =============================== FRENTE ================================== */
    const page = pdf.addPage([842, 595]); // A4 paisagem
    const { width, height } = page.getSize();

    const margin = 36;
    const left = margin;
    const right = margin;

    // Moldura fina
    page.drawRectangle({
      x: margin / 2,
      y: margin / 2,
      width: width - margin,
      height: height - margin,
      borderColor: rgb(0.75, 0.75, 0.75),
      borderWidth: 0.8,
    });

    // Elementos decorativos topo
    page.drawRectangle({ x: width - 150, y: height - 48, width: 150, height: 48, color: red });
    page.drawRectangle({ x: width - 105, y: height - 80, width: 105, height: 32, color: green });

    // Título
    let y = height - 92;
    drawCenteredText(page, "CERTIFICADO", y, 30, fontBold, red, 1.6);
    y -= 34;

    // Nome + CPF (centralizado, negrito)
    const nomeLinha = [st.aluno_nome.toUpperCase(), st.aluno_doc ? `- ${st.aluno_doc}` : ""].filter(Boolean).join(" ");
    drawCenteredText(page, nomeLinha, y, 14.5, fontBold);
    y -= 28;

    // Parágrafo principal
    const contentX = left + 28;
    const contentWidth = width - (contentX + right + 28);

    const inicioBR = formatBR(ev.data_inicio);
    const fimBR = formatBR(ev.data_fim);
    const periodo = (inicioBR || fimBR) ? `${inicioBR ?? ""}${inicioBR && fimBR ? " a " : ""}${fimBR ?? ""}` : "";
    const carga = st.carga_horaria || ev.carga_horaria || "";

    let paragraph = ev.texto_participante?.trim();
    if (paragraph) {
      paragraph = paragraph
        .replace(/\[nome do participante\]/gi, st.aluno_nome)
        .replace(/\[cpf\]/gi, st.aluno_doc || "")
        .replace(/\[carga horária\]/gi, carga);
    } else {
      const partes: string[] = [];
      partes.push(`Certificamos que ${st.aluno_nome} participou do Curso "${(ev.nome || "Curso").toUpperCase()}",`);
      partes.push("promovido e organizado pela Escola Municipal de Governo de Criciúma,");
      if (periodo) partes.push(`realizado no período de ${periodo},`);
      if (carga)  partes.push(`com carga horária de ${carga}.`);
      paragraph = partes.join(" ");
    }

    const bodySize = 12.5;
    const bodyLH = 17;
    for (const line of wrapTextByWidth({ text: paragraph, font, size: bodySize, maxWidth: contentWidth })) {
      page.drawText(line, { x: contentX, y, size: bodySize, font });
      y -= bodyLH;
    }

    // Data/Lugar à direita
    y -= 18;
    const dataFormatada = formatBR(ev.data_fim || ev.data_inicio);
    const cidade = ev.cidade_uf?.trim() || ev.local?.trim();
    const linhaData = (cidade && dataFormatada) ? `${cidade}, ${dataFormatada}.` : (dataFormatada ? `${dataFormatada}.` : "");
    if (linhaData) {
      drawRightAlignedText(page, linhaData, y, 12, font, right, gray);
    }

    // Assinaturas ao rodapé
    drawSignaturesBlock(page, font, fontBold, {
      y: 88,
      leftMargin: left,
      rightMargin: right,
      titles: [
        { name: s1name, role: s1role },
        { name: s2name, role: s2role },
        { name: (st.aluno_nome || "Participante").toUpperCase(), role: "Participante" },
      ],
    });

    /** =============================== VERSO =================================== */
    const page2 = pdf.addPage([842, 595]);
    const { width: w2, height: h2 } = page2.getSize();
    const m2 = 36;
    const left2 = m2;
    const right2 = m2;

    // moldura
    page2.drawRectangle({
      x: m2 / 2, y: m2 / 2,
      width: w2 - m2, height: h2 - m2,
      borderColor: rgb(0.85, 0.85, 0.85), borderWidth: 0.8
    });

    // Áreas e coordenadas base
    const topY = h2 - 72;                // topo do conteúdo
    const authBaseY = 86;                // faixa de autorização acima do rodapé
    const qrBoxSize = 120;               // tamanho do QR
    const qrX = left2 + 10;
    const qrY = m2 + 16;                 // canto inferior esquerdo

    // Conteúdo Programático (texto_verso) no topo-esquerda
    let y2 = topY;
    const contentX2 = left2 + 24;
    const contentW2 = w2 - (contentX2 + right2 + 24);

    if (ev.texto_verso && ev.texto_verso.trim()) {
      // Se começar com "Conteúdo" destacamos título
      const t = ev.texto_verso.trim();
      const lines = t.split(/\r?\n/).filter(Boolean);
      if (lines.length) {
        // Se a primeira linha parece título, desenha em bold
        if (/conte[uú]do/i.test(lines[0])) {
          page2.drawText(lines[0], { x: contentX2, y: y2, size: 12.5, font: fontBold });
          y2 -= 18;
          lines.slice(1).forEach((L) => {
            for (const ln of wrapTextByWidth({ text: L, font, size: 12, maxWidth: contentW2 })) {
              page2.drawText(ln, { x: contentX2, y: y2, size: 12, font });
              y2 -= 16;
            }
          });
        } else {
          for (const ln of wrapTextByWidth({ text: t, font, size: 12, maxWidth: contentW2 })) {
            page2.drawText(ln, { x: contentX2, y: y2, size: 12, font });
            y2 -= 16;
          }
        }
      }
    }

    // TOTAL no topo-direita
    const totalCarga = (st.carga_horaria || ev.carga_horaria || "").trim();
    if (totalCarga) {
      drawRightAlignedText(page2, `TOTAL: ${totalCarga}`, topY + 4, 12.5, fontBold, right2);
    }

    // QR no canto inferior esquerdo com borda
    if (ev.qr_url && ev.qr_url.trim()) {
      const qrPng = await QRCode.toBuffer(ev.qr_url.trim(), { type: "png", width: qrBoxSize, margin: 1 });
      const qrImg = await pdf.embedPng(qrPng);
      page2.drawRectangle({ x: qrX - 6, y: qrY - 6, width: qrBoxSize + 12, height: qrBoxSize + 12, borderColor: red, borderWidth: 1.2 });
      page2.drawImage(qrImg, { x: qrX, y: qrY, width: qrBoxSize, height: qrBoxSize });
    }

    // Faixa de autorização (central) e responsável (direita), ambos acima do rodapé
    const autorizacao = (ev.autorizacao_texto || "").trim();
    if (autorizacao) {
      for (const ln of wrapTextByWidth({ text: autorizacao, font, size: 12, maxWidth: w2 * 0.7 })) {
        drawCenteredText(page2, ln, authBaseY, 12, font);
        // não quebramos múltiplas linhas para manter a faixa compacta
      }
    }
    if (ev.responsavel && ev.responsavel.trim()) {
      drawRightAlignedText(page2, `Responsável: ${ev.responsavel.trim()}`, authBaseY - 16, 12, font, right2);
    }
  }

  return await pdf.save();
}

/** Handler HTTP -----------------------------------------------------------------------------*/
export async function POST(req: Request, { params }: { params: { id: string } }) {
  try {
    const body = await req.json().catch(() => ({}));
    const ev: EventPayload = body?.event;
    const alunos: Student[] = body?.students || [];

    if (!ev?.id || ev.id !== params.id) {
      return NextResponse.json({ ok: false, error: "Evento inválido" }, { status: 400 });
    }
    if (!ev?.nome) {
      return NextResponse.json({ ok: false, error: "Nome do evento é obrigatório" }, { status: 400 });
    }
    const validos = Array.isArray(alunos) ? alunos.filter((a) => a?.aluno_nome) : [];
    if (validos.length === 0) {
      return NextResponse.json({ ok: false, error: "Nenhum aluno válido fornecido" }, { status: 400 });
    }

    const pdfBytes = await buildCertificatesPDF(ev, validos);

    return new NextResponse(pdfBytes, {
      status: 200,
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="certificados-${params.id}.pdf"`,
        "Cache-Control": "no-store",
      },
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Falha ao gerar certificados" }, { status: 500 });
  }
}
