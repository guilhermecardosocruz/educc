
===== app/api/classes/route.ts =====
1 import { NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { requireUser } from "@/lib/session";
4 
5 export async function GET() {
6   const user = await requireUser();
7   if (!user) return NextResponse.json({ ok:false }, { status: 401 });
8 
9   const rows = await prisma.class.findMany({
10     where: {
11       OR: [
12         { ownerId: user.id },
13         { accesses: { some: { userId: user.id } } }
14       ]
15     },
16     orderBy: { createdAt: "desc" },
17     select: {
18       id: true,
19       name: true,
20       createdAt: true,
21       ownerId: true,
22       accesses: {
23         where: { userId: user.id },
24         select: { role: true }
25       }
26     }
27   });
28 
29   const classes = rows.map(r => {
30     const roleFromAccess = r.accesses[0]?.role ?? null;
31     const roleForMe = roleFromAccess ?? (r.ownerId === user.id ? "PROFESSOR" : null);
32     return { id: r.id, name: r.name, createdAt: r.createdAt, roleForMe };
33   });
34 
35   return NextResponse.json({ ok:true, classes });
36 }
37 
38 export async function POST(req: Request) {
39   const user = await requireUser();
40   if (!user) return NextResponse.json({ ok:false }, { status: 401 });
41 
42   const body = await req.json().catch(()=> ({}));
43   const name = (body?.name ?? "").toString().trim();
44   if (!name || name.length < 2) {
45     return NextResponse.json({ ok:false, error: "Nome da turma inválido" }, { status: 400 });
46   }
47 
48   const cls = await prisma.class.create({
49     data: {
50       name,
51       ownerId: user.id,
52       accesses: {
53         create: {
54           userId: user.id,
55           role: "PROFESSOR"
56         }
57       }
58     },
59     select: { id: true, name: true, createdAt: true }
60   });
61 
62   return NextResponse.json({ ok:true, class: cls }, { status: 201 });
63 }

===== app/api/classes/[id]/route.ts =====
1 import { NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { requireUser, getRole } from "@/lib/session";
4 
5 export async function DELETE(_req: Request, ctx: { params: Promise<{ id: string }> }) {
6   const { id } = await ctx.params;
7   const me = await requireUser();
8   if (!me) return NextResponse.json({ ok:false }, { status: 401 });
9 
10   const role = await getRole(me.id, id);
11   if (!role) return NextResponse.json({ ok:false, error:"Sem acesso" }, { status: 403 });
12   // por enquanto: permitir PROFESSOR e GESTOR
13   // if (role !== "PROFESSOR") return NextResponse.json({ ok:false, error:"Apenas professor pode excluir a turma" }, { status: 403 });
14 
15   await prisma.class.delete({ where: { id } });
16   return NextResponse.json({ ok:true, deletedId: id });
17 }

===== app/api/class-groups/route.ts =====
[MISSING] app/api/class-groups/route.ts

===== app/api/classes/[id]/access/links/route.ts =====
1 import { NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { requireUser, getRole } from "@/lib/session";
4 import { logAudit } from "@/lib/audit";
5 import { z } from "zod";
6 
7 const createSchema = z.object({
8   role: z.enum(["PROFESSOR", "GESTOR"]),
9   note: z.string().max(200).optional(),
10   promotional: z.boolean().optional(), // se true e role=PROFESSOR, ativa promo automática
11 });
12 
13 const revokeSchema = z.object({
14   linkId: z.string().min(1),
15 });
16 
17 export async function GET(_req: Request, ctx: { params: Promise<{ id: string }> }) {
18   const { id } = await ctx.params;
19   const user = await requireUser();
20   if (!user) return NextResponse.json({ ok:false }, { status: 401 });
21 
22   // GET liberado para PROFESSOR e GESTOR
23   const role = await getRole(user.id, id);
24   if (!role) return NextResponse.json({ ok:false, error:"Sem acesso" }, { status: 403 });
25 
26   const rows = await prisma.shareLink.findMany({
27     where: { classId: id, isRevoked: false },
28     orderBy: { createdAt: "desc" },
29     select: { id:true, token:true, role:true, createdAt:true, createdBy:true, isPromotional:true }
30   });
31 
32   return NextResponse.json({ ok:true, links: rows });
33 }
34 
35 export async function POST(req: Request, ctx: { params: Promise<{ id: string }> }) {
36   const { id } = await ctx.params;
37   const user = await requireUser();
38   if (!user) return NextResponse.json({ ok:false }, { status: 401 });
39 
40   // Apenas PROFESSOR cria/gera link
41   const role = await getRole(user.id, id);
42   if (role !== "PROFESSOR") return NextResponse.json({ ok:false, error:"Apenas professor pode alterar" }, { status: 403 });
43 
44   const body = await req.json().catch(()=> ({}));
45   const parsed = createSchema.safeParse(body);
46   if (!parsed.success) return NextResponse.json({ ok:false, error: parsed.error.flatten() }, { status: 400 });
47 
48   const token = crypto.randomUUID().replace(/-/g, "");
49   const created = await prisma.shareLink.create({
50     data: {
51       classId: id,
52       token,
53       role: parsed.data.role,
54       createdBy: user.id,
55       isPromotional: !!parsed.data.promotional && parsed.data.role === "PROFESSOR",
56     },
57     select: { id:true, token:true, role:true, createdAt:true, createdBy:true, isPromotional:true }
58   });
59 
60   await logAudit(id, "LINK_CREATED", {
61     actorId: user.id,
62     metadata: { linkId: created.id, role: created.role, promotional: created.isPromotional }
63   });
64 
65   return NextResponse.json({ ok:true, link: created }, { status: 201 });
66 }
67 
68 // Revogar (equivale a "rotacionar": você cria outro e revoga este)
69 export async function PATCH(req: Request, ctx: { params: Promise<{ id: string }> }) {
70   const { id } = await ctx.params;
71   const user = await requireUser();
72   if (!user) return NextResponse.json({ ok:false }, { status: 401 });
73 
74   // Apenas PROFESSOR pode revogar
75   const role = await getRole(user.id, id);
76   if (role !== "PROFESSOR") return NextResponse.json({ ok:false, error:"Apenas professor pode alterar" }, { status: 403 });
77 
78   const body = await req.json().catch(()=> ({}));
79   const parsed = revokeSchema.safeParse(body);
80   if (!parsed.success) return NextResponse.json({ ok:false, error: parsed.error.flatten() }, { status: 400 });
81 
82   const link = await prisma.shareLink.findFirst({
83     where: { id: parsed.data.linkId, classId: id, isRevoked: false },
84     select: { id:true }
85   });
86   if (!link) return NextResponse.json({ ok:false, error:"Link não encontrado" }, { status: 404 });
87 
88   await prisma.shareLink.update({
89     where: { id: link.id },
90     data: { isRevoked: true }
91   });
92 
93   await logAudit(id, "LINK_REVOKED", {
94     actorId: user.id,
95     metadata: { linkId: link.id }
96   });
97 
98   return NextResponse.json({ ok:true });
99 }

===== lib/prisma.ts =====
1 import { PrismaClient } from "@prisma/client";
2 
3 const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };
4 
5 export const prisma =
6   globalForPrisma.prisma ??
7   new PrismaClient({
8     log: ["error", "warn"],
9   });
10 
11 if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

===== lib/session.ts =====
1 import { cookies, headers } from "next/headers";
2 import { prisma } from "@/lib/prisma";
3 import { ClassRole } from "@prisma/client";
4 
5 const COOKIE_NAME = "session_user_id";
6 
7 /** Lê o userId do cookie (async em Next 15) */
8 export async function getSessionUserId(): Promise<string | null> {
9   try {
10     const c = await cookies();
11     const id = c.get(COOKIE_NAME)?.value || null;
12     return id;
13   } catch {
14     // Fallback para contexts onde cookies() não está disponível
15     const h = await headers();
16     const cookieHeader = h.get("cookie") || "";
17     const m = cookieHeader.match(new RegExp(`${COOKIE_NAME}=([^;]+)`));
18     return m ? m[1] : null;
19   }
20 }
21 
22 /** Busca o usuário logado; retorna null se não houver */
23 export async function requireUser() {
24   const id = await getSessionUserId();
25   if (!id) return null;
26   const user = await prisma.user.findUnique({
27     where: { id },
28     select: { id: true, name: true, email: true }
29   });
30   return user;
31 }
32 
33 /** Apaga o cookie de sessão (async em Next 15) */
34 export async function clearSessionCookie() {
35   const c = await cookies();
36   c.set({
37     name: COOKIE_NAME,
38     value: "",
39     httpOnly: true,
40     path: "/",
41     maxAge: 0
42   });
43 }
44 
45 // === Access helpers (ClassAccess) ============================================
46 
47 /**
48  * Retorna o papel do usuário na turma (PROFESSOR | GESTOR) ou null se não tem acesso.
49  */
50 export async function getRole(userId: string, classId: string): Promise<ClassRole | null> {
51   try {
52     const row = await prisma.classAccess.findFirst({
53       where: { classId, userId },
54       select: { role: true },
55     });
56     return row?.role ?? null;
57   } catch (_e) {
58     return null;
59   }
60 }
61 
62 /** Versão que usa o usuário logado da sessão atual. */
63 export async function getMyRole(classId: string): Promise<ClassRole | null> {
64   const me = await requireUser();
65   if (!me) return null;
66   return getRole(me.id, classId);
67 }
68 
69 /** Açúcares para checagens rápidas na UI/rota. */
70 export function roleFlags(role: ClassRole | null) {
71   return {
72     isProfessor: role === "PROFESSOR",
73     isGestor: role === "GESTOR",
74     hasAccess: role === "PROFESSOR" || role === "GESTOR",
75   };
76 }

===== lib/audit.ts =====
1 import { prisma } from "@/lib/prisma";
2 
3 export async function logAudit(
4   classId: string,
5   type: string,
6   opts?: { actorId?: string | null; metadata?: any }
7 ) {
8   try {
9     await prisma.auditLog.create({
10       data: {
11         classId,
12         actorId: opts?.actorId ?? null,
13         type,
14         metadata: opts?.metadata ?? null,
15       },
16     });
17   } catch (err) {
18     // auditoria não deve derrubar a request principal
19     console.error("auditLog error", { classId, type, err });
20   }
21 }

===== components/ShareClassModal.tsx =====
1 "use client";
2 import { useState, useEffect } from "react";
3 
4 type LinkRow = { id: string; token: string; role: "PROFESSOR" | "GESTOR"; createdAt: string; createdBy: string; isPromotional?: boolean };
5 type Props = { classId: string; open?: boolean; onOpenChange?: (v: boolean) => void; };
6 
7 export default function ShareClassModal({ classId, open: openProp, onOpenChange }: Props) {
8   const [internalOpen, setInternalOpen] = useState(false);
9   const open = openProp ?? internalOpen;
10   const setOpen = onOpenChange ?? setInternalOpen;
11 
12   const [loading, setLoading] = useState(false);
13   const [links, setLinks] = useState<LinkRow[]>([]);
14   const [msg, setMsg] = useState<string | null>(null);
15   const [err, setErr] = useState<string | null>(null);
16   const [email, setEmail] = useState("");
17   const [inviteRole, setInviteRole] = useState<"PROFESSOR" | "GESTOR">("GESTOR");
18 
19   async function loadLinks() {
20     setLoading(true); setErr(null);
21     try {
22       const res = await fetch(`/api/classes/${classId}/access/links`, { cache: "no-store" });
23       const data = await res.json();
24       if (!res.ok || !data?.ok) throw new Error(data?.error ?? "Falha ao listar links");
25       setLinks(data.links || []);
26     } catch (e: any) { setErr(e.message || "Erro ao carregar links"); }
27     finally { setLoading(false); }
28   }
29 
30   useEffect(() => { if (open) loadLinks(); }, [open]);
31 
32   async function createLink(role: "PROFESSOR" | "GESTOR") {
33     setLoading(true); setMsg(null); setErr(null);
34     try {
35       let body: any = { role };
36       if (role === "PROFESSOR") {
37         const ok = confirm("Ao enviar um link de PROFESSOR, você se tornará GESTOR quando o convidado aceitar. Deseja continuar?");
38         if (!ok) { setLoading(false); return; }
39         body.promotional = true; // ativa promoção automática (criador -> GESTOR, convidado -> PROFESSOR)
40       }
41       const res = await fetch(`/api/classes/${classId}/access/links`, {
42         method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(body)
43       });
44       const data = await res.json();
45       if (!res.ok || !data?.ok) throw new Error(data?.error ?? "Falha ao criar link");
46       setMsg(role === "PROFESSOR" ? "Link de professor (promocional) criado!" : "Link de gestor criado!");
47       await loadLinks();
48     } catch (e: any) { setErr(e.message || "Erro ao criar link"); }
49     finally { setLoading(false); }
50   }
51 
52   async function copyLink(token: string) {
53     const url = `${window.location.origin}/share/${token}`;
54     try { await navigator.clipboard.writeText(url); setMsg("Link copiado!"); }
55     catch { setErr("Não consegui copiar — copie manualmente:"); }
56   }
57 
58   async function inviteByEmail() {
59     setLoading(true); setMsg(null); setErr(null);
60     try {
61       if (inviteRole === "PROFESSOR") {
62         const ok = confirm("Ao convidar um PROFESSOR por e-mail, você se tornará GESTOR automaticamente. Deseja continuar?");
63         if (!ok) { setLoading(false); return; }
64       }
65       const res = await fetch(`/api/classes/${classId}/access/members`, {
66         method: "POST",
67         headers: { "content-type": "application/json" },
68         body: JSON.stringify({ email, role: inviteRole })
69       });
70       const data = await res.json();
71       if (!res.ok || !data?.ok) throw new Error(data?.error ?? "Falha ao convidar");
72       setMsg(`Acesso concedido a ${email} como ${inviteRole}.`);
73       setEmail("");
74       await loadLinks();
75     } catch (e: any) { setErr(e.message || "Erro ao convidar"); }
76     finally { setLoading(false); }
77   }
78 
79   return (
80     <>
81       {openProp === undefined && (
82         <button
83           type="button"
84           className="p-2 rounded-lg border border-gray-300 hover:bg-gray-50"
85           onClick={() => setOpen(true)}
86           aria-label="Compartilhar turma" title="Compartilhar"
87         >
88           <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
89             <path d="M16 6a3 3 0 1 0-2.83-4H13a3 3 0 0 0 3 4Z" fill="currentColor" opacity=".15"/>
90             <path d="M18 8a3 3 0 1 0-2.83-4M6 14a3 3 0 1 0 2.83 4M6 14l9-5M8.83 18l7.34 4" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round"/>
91           </svg>
92         </button>
93       )}
94 
95       {open && (
96         <div className="fixed inset-0 z-50">
97           <div className="absolute inset-0 bg-black/30" onClick={() => setOpen(false)} aria-hidden="true" />
98           <div className="absolute inset-0 flex items-center justify-center p-4">
99             <div className="w-full max-w-lg rounded-xl bg-white p-5 shadow-xl">
100               <div className="flex items-center justify-between mb-3">
101                 <h2 className="text-lg font-semibold">Compartilhar turma</h2>
102                 <button className="p-1 rounded-md hover:bg-gray-100" onClick={() => setOpen(false)} aria-label="Fechar">✕</button>
103               </div>
104 
105               <p className="text-sm text-gray-600 mb-3">Convide como <strong>Professor</strong> (único) ou <strong>Gestor</strong> (vários).</p>
106 
107               <div className="space-y-4">
108                 <div className="flex flex-wrap gap-2">
109                   <button
110                     className="px-3 py-1.5 rounded-lg border border-gray-300 hover:bg-gray-50 text-sm"
111                     onClick={() => createLink("GESTOR")}
112                     disabled={loading}
113                   >
114                     Criar link de Gestor
115                   </button>
116                   <button
117                     className="px-3 py-1.5 rounded-lg border border-red-300 bg-red-50 hover:bg-red-100 text-red-700 text-sm disabled:opacity-60"
118                     onClick={() => createLink("PROFESSOR")}
119                     disabled={loading}
120                     title="Cria link promocional: você vira Gestor quando o convidado aceitar"
121                   >
122                     Criar link de Professor (promocional)
123                   </button>
124                 </div>
125 
126                 <div>
127                   <div className="text-sm font-medium mb-2">Convidar por e-mail (usuário já cadastrado)</div>
128                   <div className="flex gap-2">
129                     <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="usuario@exemplo.com" className="w-full rounded-md border px-3 py-1.5 text-sm" />
130                     <select value={inviteRole} onChange={(e) => setInviteRole(e.target.value as any)} className="rounded-md border px-2 py-1.5 text-sm">
131                       <option value="GESTOR">Gestor</option>
132                       <option value="PROFESSOR">Professor</option>
133                     </select>
134                     <button disabled={loading || !email} onClick={inviteByEmail} className="px-3 py-1.5 rounded-lg bg-blue-600 text-white disabled:opacity-60">Convidar</button>
135                   </div>
136                 </div>
137 
138                 <div className="border rounded-md">
139                   <div className="p-3 border-b text-sm font-medium">Links ativos</div>
140                   <div className="max-h-64 overflow-auto divide-y">
141                     {loading ? (
142                       <div className="p-3 text-sm text-gray-500">Carregando…</div>
143                     ) : links.length === 0 ? (
144                       <div className="p-3 text-sm text-gray-500">Nenhum link criado ainda.</div>
145                     ) : (
146                       links.map((l) => {
147                         const url = typeof window !== "undefined" ? `${window.location.origin}/share/${l.token}` : `/share/${l.token}`;
148                         return (
149                           <div key={l.id} className="p-3 flex items-center justify-between gap-3">
150                             <div className="min-w-0">
151                               <div className="text-sm font-medium">
152                                 {l.role} {l.isPromotional ? <span className="ml-1 inline-block rounded-full bg-yellow-50 text-yellow-700 border border-yellow-200 px-1.5 py-0.5 text-[11px]">promocional</span> : null}
153                               </div>
154                               <div className="text-xs text-gray-500 truncate">{url}</div>
155                             </div>
156                             <div className="flex items-center gap-2 shrink-0">
157                               <button className="px-2 py-1 rounded-md border border-gray-300 hover:bg-gray-50 text-sm" onClick={() => copyLink(l.token)}>Copiar</button>
158                             </div>
159                           </div>
160                         );
161                       })
162                     )}
163                   </div>
164                 </div>
165 
166                 {msg && <div className="text-sm text-green-700 bg-green-50 border border-green-200 rounded-md p-2">{msg}</div>}
167                 {err && <div className="text-sm text-red-700 bg-red-50 border border-red-200 rounded-md p-2">{err}</div>}
168               </div>
169 
170               <div className="mt-4 text-right">
171                 <button className="px-3 py-1.5 rounded-lg border border-gray-300 hover:bg-gray-50" onClick={() => setOpen(false)}>Fechar</button>
172               </div>
173             </div>
174           </div>
175         </div>
176       )}
177     </>
178   );
179 }
