
===== components/GroupReportButton.tsx =====
1 "use client";
2 import { useMemo, useState } from "react";
3 import DateRangePicker from "./DateRangePicker";
4 
5 export default function GroupReportButton({ groupId }: { groupId: string }) {
6   const today = useMemo(() => {
7     const d = new Date();
8     const yyyy = d.getFullYear();
9     const mm = String(d.getMonth() + 1).padStart(2, "0");
10     const dd = String(d.getDate()).padStart(2, "0");
11     return `${yyyy}-${mm}-${dd}`;
12   }, []);
13   const monthStart = useMemo(() => {
14     const d = new Date();
15     const yyyy = d.getFullYear();
16     const mm = String(d.getMonth() + 1).padStart(2, "0");
17     return `${yyyy}-${mm}-01`;
18   }, []);
19 
20   const [range, setRange] = useState<{ from: string; to: string }>({ from: monthStart, to: today });
21   const [loading, setLoading] = useState(false);
22   const disabled = loading || !range.from || !range.to;
23 
24   async function handleGenerate() {
25     if (!range.from || !range.to) return;
26     setLoading(true);
27     try {
28       const qs = new URLSearchParams({ from: range.from, to: range.to }).toString();
29       const res = await fetch(`/api/class-groups/${groupId}/report?${qs}`, {
30         method: "GET",
31       });
32       if (!res.ok) {
33         const msg = await res.text().catch(() => "Falha ao gerar PDF");
34         throw new Error(msg || "Falha ao gerar PDF");
35       }
36       const blob = await res.blob();
37       const url = URL.createObjectURL(blob);
38       window.open(url, "_blank", "noopener,noreferrer");
39       window.open(url, "_blank", "noopener,noreferrer");
40       const a = document.createElement("a");
41       a.href = url;
42       a.download = `relatorio-grupo-${groupId}-${range.from}_a_${range.to}.pdf`;
43       document.body.appendChild(a);
44       a.click();
45       a.remove();
46       setTimeout(() => URL.revokeObjectURL(url), 1000);
47     } catch (e: any) {
48       alert(e?.message || "Erro ao gerar relatório");
49       console.error(e);
50     } finally {
51       setLoading(false);
52     }
53   }
54 
55   return (
56     <div className="flex flex-col gap-3">
57       <DateRangePicker from={range.from} to={range.to} onChange={setRange} disabled={loading} />
58       <div className="flex items-center gap-2">
59         <button
60           type="button"
61           onClick={handleGenerate}
62           disabled={disabled}
63           className="rounded-xl bg-[#0A66FF] px-4 py-2 text-sm font-medium text-white shadow hover:opacity-90 disabled:opacity-60"
64         >
65           {loading ? "Gerando PDF..." : "Gerar relatório em PDF"}
66         </button>
67         <span className="text-xs text-gray-600">Média de presença (abs. e %) e Top 5 faltantes por turma.</span>
68       </div>
69     </div>
70   );
71 }

===== components/GroupAIReportPromptButton.tsx =====
1 "use client";
2 
3 import { useMemo, useState } from "react";
4 import DateRangePicker from "./DateRangePicker";
5 
6 type APIItem = {
7   classId: string;
8   className: string;
9   contents: Array<{
10     seq: number;
11     title: string;
12     objetivos?: string | null;
13     desenvolvimento?: string | null;
14     recursos?: string | null;
15     bncc?: string | null;
16     lessonDate?: string | null;
17   }>;
18 };
19 
20 export default function GroupAIReportPromptButton({ groupId }: { groupId: string }) {
21   const today = useMemo(() => {
22     const d = new Date();
23     const yyyy = d.getFullYear();
24     const mm = String(d.getMonth() + 1).padStart(2, "0");
25     const dd = String(d.getDate()).padStart(2, "0");
26     return `${yyyy}-${mm}-${dd}`;
27   }, []);
28   const monthStart = useMemo(() => {
29     const d = new Date();
30     const yyyy = d.getFullYear();
31     const mm = String(d.getMonth() + 1).padStart(2, "0");
32     return `${yyyy}-${mm}-01`;
33   }, []);
34 
35   const [range, setRange] = useState<{ from: string; to: string }>({ from: monthStart, to: today });
36   const [loading, setLoading] = useState(false);
37   const [prompt, setPrompt] = useState<string>("");
38 
39   async function handleBuildPrompt() {
40     if (!range.from || !range.to) return;
41     setLoading(true);
42     try {
43       const qs = new URLSearchParams({ from: range.from, to: range.to }).toString();
44       const res = await fetch(`/api/class-groups/${groupId}/contents?${qs}`, { method: "GET", cache: "no-store" });
45       const data = await res.json().catch(() => ({}));
46       if (!res.ok || !data?.ok) throw new Error(data?.error || "Falha ao carregar conteúdos");
47 
48       const items: APIItem[] = data.items ?? [];
49       const groupName: string = data.group?.name ?? "Grupo";
50 
51       const lines: string[] = [];
52       lines.push(`Você é um coordenador pedagógico. Gere um RELATÓRIO DE CHAMADAS E CONTEÚDOS para o grupo "${groupName}".`);
53       lines.push(`Período analisado: ${range.from} a ${range.to}.`);
54       lines.push("");
55       lines.push("Estrutura desejada do relatório:");
56       lines.push("1) Sumário executivo (1 parágrafo curto).");
57       lines.push("2) Ações programadas (por turma):");
58       lines.push("   - Liste os conteúdos planejados com base nos títulos e objetivos.");
59       lines.push("3) Ações executadas (por turma):");
60       lines.push("   - Para cada conteúdo, descreva: Título, Objetivo, Desenvolvimento das atividades (resumo), Recursos pedagógicos utilizados.");
61       lines.push("4) Observações e recomendações (pontos de atenção, intervenções futuras).");
62       lines.push("");
63       lines.push("Dados brutos por turma (use-os como base, reescrevendo em tom claro e profissional):");
64 
65       for (const it of items) {
66         lines.push("");
67         lines.push(`Turma: ${it.className}`);
68         if (!it.contents?.length) {
69           lines.push("  (Sem conteúdos registrados no período.)");
70           continue;
71         }
72         for (const c of it.contents) {
73           const d = c.lessonDate ? new Date(c.lessonDate).toLocaleDateString("pt-BR") : "";
74           lines.push(`- [${d || "s/ data"}] Seq ${c.seq} — Título: ${c.title || "(sem título)"}`);
75           if (c.objetivos) lines.push(`  Objetivo: ${c.objetivos}`);
76           if (c.desenvolvimento) lines.push(`  Desenvolvimento: ${c.desenvolvimento}`);
77           if (c.recursos) lines.push(`  Recursos pedagógicos: ${c.recursos}`);
78           if (c.bncc) lines.push(`  BNCC: ${c.bncc}`);
79         }
80       }
81 
82       lines.push("");
83       lines.push("Formato de saída: Markdown com títulos claros (## Ações programadas, ## Ações executadas, etc.).");
84       setPrompt(lines.join("\n"));
85       (document.getElementById("aiPromptModal") as HTMLDialogElement | null)?.showModal();
86     } catch (e: any) {
87       alert(e?.message || "Erro ao montar prompt");
88       console.error(e);
89     } finally {
90       setLoading(false);
91     }
92   }
93 
94   function copyToClipboard() {
95     navigator.clipboard.writeText(prompt).then(
96       () => alert("Prompt copiado!"),
97       () => alert("Falha ao copiar para a área de transferência.")
98     );
99   }
100 
101   return (
102     <div className="flex flex-col gap-3">
103       <DateRangePicker from={range.from} to={range.to} onChange={setRange} disabled={loading} />
104       <div className="flex items-center gap-2">
105         <button
106           type="button"
107           onClick={handleBuildPrompt}
108           disabled={loading}
109           className="rounded-xl bg-black px-4 py-2 text-sm font-medium text-white shadow hover:opacity-90 disabled:opacity-60"
110         >
111           {loading ? "Montando prompt..." : "Gerar prompt (GPT)"}
112         </button>
113         <span className="text-xs text-gray-600">Cria um texto-base para relatório pedagógico.</span>
114       </div>
115 
116       {/* Modal nativo simples */}
117       <dialog id="aiPromptModal" className="rounded-xl p-0 w-[min(900px,95vw)]">
118         <form method="dialog" className="p-0">
119           <div className="px-5 py-3 border-b flex items-center justify-between">
120             <h3 className="font-semibold">Prompt para Relatório (copie e cole no GPT)</h3>
121             <button className="text-sm px-2 py-1 rounded-md border hover:bg-gray-50">Fechar</button>
122           </div>
123           <div className="p-4">
124             <textarea
125               readOnly
126               value={prompt}
127               className="w-full h-[50vh] rounded-md border p-3 text-sm font-mono"
128             />
129             <div className="mt-3 flex items-center gap-2">
130               <button
131                 type="button"
132                 onClick={copyToClipboard}
133                 className="rounded-md border px-3 py-1.5 text-sm hover:bg-gray-50"
134               >
135                 Copiar
136               </button>
137               <a
138                 href="https://chat.openai.com/"
139                 target="_blank"
140                 rel="noopener noreferrer"
141                 className="rounded-md border px-3 py-1.5 text-sm hover:bg-gray-50"
142                 title="Abrir ChatGPT Web em nova aba"
143               >
144                 Abrir ChatGPT Web
145               </a>
146             </div>
147           </div>
148         </form>
149       </dialog>
150     </div>
151   );
152 }

===== app/groups/[groupId]/page.tsx =====
1 'use client';
2 
3 import { useEffect, useState } from 'react';
4 import { useEffect, useState } from 'react';
5 import Link from 'next/link';
6 import Link from 'next/link';
7 import { useRouter, useParams } from 'next/navigation';
8 import { useRouter, useParams } from 'next/navigation';
9 import GroupReportButton from '@/components/GroupReportButton';
10 import GroupAIReportPromptButton from "@/components/GroupAIReportPromptButton";
11 
12 type ClassLite = { id: string; name: string };
13 type GroupDetail = { id: string; name: string; classes: ClassLite[] };
14 
15 export default function GroupPage() {
16   const router = useRouter();
17   const params = useParams<{ groupId: string }>();
18   const groupId = params?.groupId as string;
19 
20   const [loading, setLoading] = useState(true);
21   const [err, setErr] = useState<string | null>(null);
22   const [group, setGroup] = useState<GroupDetail | null>(null);
23 
24   async function load() {
25     setLoading(true);
26     setErr(null);
27     try {
28       const res = await fetch(`/api/class-groups/${groupId}`, { cache: 'no-store' });
29       const data = await res.json().catch(() => ({}));
30       if (!res.ok || !data?.ok) throw new Error(data?.error ?? 'Falha ao carregar grupo');
31       const g = data.group as GroupDetail;
32       setGroup({ id: g.id, name: g.name, classes: data.classes ?? g.classes ?? [] });
33     } catch (e: any) {
34       setErr(e?.message || 'Erro ao carregar');
35     } finally {
36       setLoading(false);
37     }
38   }
39 
40   useEffect(() => { load(); }, []); // eslint-disable-line react-hooks/exhaustive-deps
41 
42   if (loading) {
43     return (
44       <main className="min-h-screen flex items-center justify-center">
45         Carregando...
46       </main>
47     );
48   }
49 
50   if (err) {
51     return (
52       <main className="min-h-screen flex items-center justify-center">
53         <div className="card p-6">
54           <p className="text-red-600">{err}</p>
55           <div className="mt-4">
56             <button onClick={() => router.back()} className="btn-primary">Voltar</button>
57           </div>
58         </div>
59       </main>
60     );
61   }
62 
63   if (!group) {
64     return (
65       <main className="min-h-screen flex items-center justify-center">
66         <div className="card p-6">
67           <p className="text-gray-600">Grupo não encontrado.</p>
68           <div className="mt-4">
69             <button onClick={() => router.back()} className="btn-primary">Voltar</button>
70           </div>
71         </div>
72       </main>
73     );
74   }
75 
76   return (
77     <main className="min-h-screen p-6 lg:p-10">
78       <header className="flex items-center justify-between max-w-5xl mx-auto mb-6">
79         <div className="flex items-center gap-3">
80           <button
81             onClick={() => router.back()}
82             className="inline-flex items-center gap-2 px-3 py-1.5 rounded-md border hover:bg-gray-50"
83             aria-label="Voltar"
84             title="Voltar"
85           >
86             ← Voltar
87           </button>
88           <h1 className="text-xl font-semibold">Grupo: {group.name}</h1>
89         </div>
90         <Link href="/dashboard" className="text-sm text-[var(--color-brand-blue)] hover:underline">
91           Ir para Dashboard
92         </Link>
93       </header>
94 
95       <section className="max-w-5xl mx-auto space-y-6">
96         {/* Turmas do grupo (clicáveis) */}
97         <div className="card p-6">
98           <h2 className="font-semibold mb-3">Turmas deste grupo</h2>
99           {group.classes?.length ? (
100             <div className="flex flex-wrap gap-2">
101               {group.classes.map((c) => (
102                 <Link
103                   key={c.id}
104                   href={`/classes/${c.id}`}
105                   className="px-3 py-1.5 rounded-full border hover:bg-gray-50 text-sm"
106                   title={`Abrir turma: ${c.name}`}
107                 >
108                   {c.name}
109                 </Link>
110               ))}
111             </div>
112           ) : (
113             <p className="text-gray-600 text-sm">Nenhuma turma vinculada a este grupo.</p>
114           )}
115         </div>
116 
117         {/* Relatórios */}
118         <div className="card p-6">
119           <h2 className="font-semibold mb-3">Relatórios</h2>
120           <GroupReportButton groupId={group.id} />
121           <div className="mt-5 border-t pt-5">
122             <h3 className="font-medium mb-2">Assistente (GPT)</h3>
123             <GroupAIReportPromptButton groupId={group.id} />
124           </div>
125         </div>
126       </section>
127     </main>
128   );
129 }

===== app/api/class-groups/[groupId]/contents/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { requireUser } from "@/lib/session";
4 
5 /**
6  * GET /api/class-groups/[groupId]/contents?from=YYYY-MM-DD&to=YYYY-MM-DD
7  * Retorna, por turma do grupo, os conteúdos (seq espelhado) lecionados no período.
8  * Cruza Attendance(lessonDate) com Content(seq).
9  */
10 export async function GET(req: NextRequest, { params }: { params: { groupId: string } }) {
11   try {
12     const me = await requireUser();
13     if (!me) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });
14 
15     const groupId = params.groupId;
16     const { searchParams } = new URL(req.url);
17     const from = searchParams.get("from");
18     const to = searchParams.get("to");
19     if (!from || !to) return NextResponse.json({ ok: false, error: "missing from/to" }, { status: 400 });
20 
21     // valida grupo pertence ao usuário
22     const g = await prisma.group.findFirst({
23       where: { id: groupId, userId: me.id },
24       select: { id: true, name: true },
25     });
26     if (!g) return NextResponse.json({ ok: false, error: "group not found" }, { status: 404 });
27 
28     // classes do grupo (via membership)
29     const memberships = await prisma.classGroupMembership.findMany({
30       where: { groupId: g.id },
31       select: { cls: { select: { id: true, name: true } } },
32       orderBy: { createdAt: "asc" },
33     });
34 
35     const classes = memberships
36       .map(m => m.cls)
37       .filter((c): c is { id: string; name: string } => !!c);
38 
39     const result: Array<{
40       classId: string;
41       className: string;
42       contents: Array<{
43         seq: number;
44         title: string;
45         objetivos?: string | null;
46         desenvolvimento?: string | null;
47         recursos?: string | null;
48         bncc?: string | null;
49         lessonDate?: string | null; // ISO
50       }>;
51     }> = [];
52 
53     for (const cls of classes) {
54       // Aulas no período
55       const atts = await prisma.attendance.findMany({
56         where: {
57           classId: cls.id,
58           lessonDate: { gte: new Date(from), lte: new Date(to) },
59         },
60         select: { seq: true, lessonDate: true },
61         orderBy: { seq: "asc" },
62       });
63 
64       if (atts.length === 0) {
65         result.push({ classId: cls.id, className: cls.name, contents: [] });
66         continue;
67       }
68 
69       const seqs = atts.map(a => a.seq);
70       const conts = await prisma.content.findMany({
71         where: { classId: cls.id, seq: { in: seqs } },
72         select: { seq: true, title: true, objetivos: true, desenvolvimento: true, recursos: true, bncc: true },
73         orderBy: { seq: "asc" },
74       });
75 
76       const dateBySeq = new Map(atts.map(a => [a.seq, a.lessonDate?.toISOString() ?? null]));
77       const contents = conts.map(c => ({ ...c, lessonDate: dateBySeq.get(c.seq) ?? null }));
78 
79       result.push({ classId: cls.id, className: cls.name, contents });
80     }
81 
82     return NextResponse.json({ ok: true, group: g, from, to, items: result });
83   } catch (e: any) {
84     return NextResponse.json({ ok: false, error: e?.message || "internal error" }, { status: 500 });
85   }
86 }

===== app/api/class-groups/[groupId]/report/route.ts =====
1 export const runtime = "nodejs";
2 export const dynamic = "force-dynamic";
3 
4 import { prisma } from "@/lib/prisma";
5 import { requireUser } from "@/lib/session";
6 import { getGroupAttendanceSummary } from "@/lib/analytics/attendance";
7 import { buildGroupReportPDF } from "@/lib/report/pdf";
8 
9 export async function HEAD(_req: Request, { params }: { params: { groupId: string } }) {
10   // HEAD “saudável” para Vercel/Next
11   return new Response(null, { status: 204 });
12 }
13 
14 export async function GET(req: Request, { params }: { params: { groupId: string } }) {
15   try {
16     const me = await requireUser();
17     if (!me) {
18       return new Response(JSON.stringify({ ok: false, error: "unauthorized" }), {
19         status: 401,
20         headers: { "content-type": "application/json" },
21       });
22     }
23 
24     const groupId = params.groupId;
25     const url = new URL(req.url);
26     const from = url.searchParams.get("from");
27     const to = url.searchParams.get("to");
28     if (!from || !to) {
29       return new Response(JSON.stringify({ ok: false, error: "missing from/to" }), {
30         status: 400,
31         headers: { "content-type": "application/json" },
32       });
33     }
34 
35     // grupo do usuário (mesma regra das rotas existentes)
36     const g = await prisma.group.findFirst({
37       where: { id: groupId, userId: me.id },
38       select: { id: true, name: true },
39     });
40     if (!g) {
41       return new Response(JSON.stringify({ ok: false, error: "group not found" }), {
42         status: 404,
43         headers: { "content-type": "application/json" },
44       });
45     }
46 
47     const summaries = await getGroupAttendanceSummary(g.id, from, to);
48     const pdf = await buildGroupReportPDF({ groupName: g.name, from, to, summaries });
49 
50     return new Response(pdf, {
51       status: 200,
52       headers: {
53         "content-type": "application/pdf",
54         "content-disposition": `attachment; filename="relatorio-grupo-${g.id}-${from}_a_${to}.pdf"`,
55         "cache-control": "no-store",
56       },
57     });
58   } catch (e: any) {
59     return new Response(JSON.stringify({ ok: false, error: e?.message || "internal error" }), {
60       status: 500,
61       headers: { "content-type": "application/json" },
62     });
63   }
64 }

===== app/api/class-groups/[groupId]/analytics/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { requireUser } from "@/lib/session";
4 import { getGroupAttendanceSummary } from "@/lib/analytics/attendance";
5 
6 export async function GET(req: NextRequest, { params }: { params: { groupId: string } }) {
7   try {
8     const me = await requireUser();
9     if (!me) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });
10 
11     const groupId = params.groupId;
12     const { searchParams } = new URL(req.url);
13     const from = searchParams.get("from");
14     const to = searchParams.get("to");
15     if (!from || !to) return NextResponse.json({ ok: false, error: "missing from/to" }, { status: 400 });
16 
17     // grupo precisa ser do usuário (igual às rotas existentes)
18     const g = await prisma.group.findFirst({
19       where: { id: groupId, userId: me.id },
20       select: { id: true, name: true },
21     });
22     if (!g) return NextResponse.json({ ok: false, error: "group not found" }, { status: 404 });
23 
24     const summaries = await getGroupAttendanceSummary(g.id, from, to);
25     return NextResponse.json({ ok: true, group: g, summaries });
26   } catch (e: any) {
27     return NextResponse.json({ ok: false, error: e?.message || "internal error" }, { status: 500 });
28   }
29 }

===== app/api/class-groups/[groupId]/route.ts =====
1 import { NextResponse } from 'next/server';
2 import { prisma } from '@/lib/prisma';
3 import { requireUser } from '@/lib/session';
4 
5 export async function GET(_req: Request, ctx: { params: Promise<{ groupId: string }> }) {
6   const { groupId } = await ctx.params;
7   const me = await requireUser();
8   if (!me) return NextResponse.json({ ok:false }, { status: 401 });
9 
10   // Grupo precisa ser do usuário (escopo por owner)
11   const g = await prisma.group.findFirst({
12     where: { id: groupId, userId: me.id },
13     select: { id:true, name:true }
14   });
15   if (!g) return NextResponse.json({ ok:false, error:'Grupo não encontrado' }, { status: 404 });
16 
17   const memberships = await prisma.classGroupMembership.findMany({
18     where: { groupId: g.id },
19     select: { classId: true, cls: { select: { id:true, name:true } } },
20     orderBy: { createdAt: 'asc' }
21   });
22 
23   const classes = memberships.map(m => m.cls);
24 
25   return NextResponse.json({ ok:true, group: g, classes });
26 }

===== lib/analytics/attendance.ts =====
1 import { prisma } from "@/lib/prisma";
2 
3 export type ClassSummary = {
4   classId: string;
5   className: string;
6   lessonsCount: number;          // nº de aulas no período
7   avgPresentAbsolute: number;    // média de presentes (absoluto)
8   avgPresentPercent: number;     // média de presença (%)
9   topAbsentees: Array<{ studentId: string; name: string; absences: number }>;
10 };
11 
12 /**
13  * Busca as turmas do grupo via tabela de junção ClassGroupMembership (campo relacional 'cls'),
14  * exatamente como já é feito nas rotas existentes.
15  */
16 export async function getGroupAttendanceSummary(groupId: string, from: string, to: string): Promise<ClassSummary[]> {
17   // memberships com relação para a turma
18   const memberships = await prisma.classGroupMembership.findMany({
19     where: { groupId },
20     select: { cls: { select: { id: true, name: true } } },
21     orderBy: { createdAt: "asc" },
22   });
23 
24   const classes = memberships
25     .map((m) => m.cls)
26     .filter((c): c is { id: string; name: string } => !!c);
27 
28   const summaries: ClassSummary[] = [];
29 
30   for (const cls of classes) {
31     // aulas no período
32     const attendances = await prisma.attendance.findMany({
33       where: {
34         classId: cls.id,
35         lessonDate: { gte: new Date(from), lte: new Date(to) },
36       },
37       select: { seq: true },
38       orderBy: { seq: "asc" },
39     });
40 
41     if (attendances.length === 0) {
42       summaries.push({
43         classId: cls.id,
44         className: cls.name,
45         lessonsCount: 0,
46         avgPresentAbsolute: 0,
47         avgPresentPercent: 0,
48         topAbsentees: [],
49       });
50       continue;
51     }
52 
53     // lista atual de alunos (divisor padrão para %)
54     const students = await prisma.student.findMany({
55       where: { classId: cls.id },
56       select: { id: true, name: true },
57       orderBy: { createdAt: "asc" },
58     });
59     const studentMap = new Map(students.map((s) => [s.id, s.name]));
60 
61     let sumPresent = 0;
62     let sumPercent = 0;
63     const absencesCounter = new Map<string, number>();
64 
65     for (const att of attendances) {
66       const presences = await prisma.attendancePresence.findMany({
67         where: { classId: cls.id, seq: att.seq },
68         select: { studentId: true, present: true },
69       });
70 
71       const totalThisClassList = students.length > 0 ? students.length : presences.length;
72       const presentCount = presences.reduce((acc, r) => acc + (r.present ? 1 : 0), 0);
73 
74       sumPresent += presentCount;
75       sumPercent += totalThisClassList > 0 ? presentCount / totalThisClassList : 0;
76 
77       for (const r of presences) {
78         if (!r.present) {
79           absencesCounter.set(r.studentId, (absencesCounter.get(r.studentId) || 0) + 1);
80         }
81       }
82     }
83 
84     const lessonsCount = attendances.length;
85     const avgPresentAbsolute = lessonsCount > 0 ? sumPresent / lessonsCount : 0;
86     const avgPresentPercent = lessonsCount > 0 ? (sumPercent / lessonsCount) * 100 : 0;
87 
88     const topAbsentees = Array.from(absencesCounter.entries())
89       .map(([studentId, absences]) => ({
90         studentId,
91         name: studentMap.get(studentId) || "Aluno",
92         absences,
93       }))
94       .sort((a, b) => b.absences - a.absences)
95       .slice(0, 5);
96 
97     summaries.push({
98       classId: cls.id,
99       className: cls.name,
100       lessonsCount,
101       avgPresentAbsolute: Number(avgPresentAbsolute.toFixed(2)),
102       avgPresentPercent: Number(avgPresentPercent.toFixed(2)),
103       topAbsentees,
104     });
105   }
106 
107   return summaries;
108 }

===== lib/report/pdf.ts =====
1 import { PDFDocument, StandardFonts, rgb } from "pdf-lib";
2 import { ClassSummary } from "@/lib/analytics/attendance";
3 
4 export async function buildGroupReportPDF({
5   groupName,
6   from,
7   to,
8   summaries,
9 }: {
10   groupName: string;
11   from: string;
12   to: string;
13   summaries: ClassSummary[];
14 }): Promise<Uint8Array> {
15   const pdfDoc = await PDFDocument.create();
16   const page = pdfDoc.addPage([595, 842]); // A4 size
17   const { height } = page.getSize();
18 
19   const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
20   let y = height - 50;
21 
22   page.drawText(`Relatório de Presenças — Grupo: ${groupName}`, {
23     x: 50,
24     y,
25     size: 16,
26     font,
27     color: rgb(0, 0, 0),
28   });
29   y -= 25;
30 
31   page.drawText(`Período: ${from} a ${to}`, {
32     x: 50,
33     y,
34     size: 10,
35     font,
36     color: rgb(0.3, 0.3, 0.3),
37   });
38   y -= 40;
39 
40   for (const s of summaries) {
41     page.drawText(`Turma: ${s.className}`, {
42       x: 50,
43       y,
44       size: 13,
45       font,
46       color: rgb(0, 0, 0),
47     });
48     y -= 20;
49 
50     page.drawText(`Aulas no período: ${s.lessonsCount}`, { x: 60, y, size: 10, font });
51     y -= 15;
52     page.drawText(`Média de presentes (abs.): ${s.avgPresentAbsolute}`, { x: 60, y, size: 10, font });
53     y -= 15;
54     page.drawText(`Média de presença (%): ${s.avgPresentPercent}%`, { x: 60, y, size: 10, font });
55     y -= 25;
56 
57     page.drawText("Top 5 mais faltantes:", { x: 60, y, size: 11, font });
58     y -= 15;
59 
60     if (s.topAbsentees.length === 0) {
61       page.drawText("— Sem dados de faltas no período.", { x: 70, y, size: 10, font });
62       y -= 20;
63     } else {
64       for (const [i, st] of s.topAbsentees.entries()) {
65         page.drawText(`${i + 1}. ${st.name} — ${st.absences} falta(s)`, {
66           x: 70,
67           y,
68           size: 10,
69           font,
70         });
71         y -= 15;
72       }
73     }
74     y -= 20;
75   }
76 
77   const pdfBytes = await pdfDoc.save();
78   return pdfBytes;
79 }

===== lib/session.ts =====
1 import { cookies, headers } from "next/headers";
2 import { prisma } from "@/lib/prisma";
3 import { ClassRole } from "@prisma/client";
4 
5 const COOKIE_NAME = "session_user_id";
6 
7 /** Lê o userId do cookie (async em Next 15) */
8 export async function getSessionUserId(): Promise<string | null> {
9   try {
10     const c = await cookies();
11     const id = c.get(COOKIE_NAME)?.value || null;
12     return id;
13   } catch {
14     // Fallback para contexts onde cookies() não está disponível
15     const h = await headers();
16     const cookieHeader = h.get("cookie") || "";
17     const m = cookieHeader.match(new RegExp(`${COOKIE_NAME}=([^;]+)`));
18     return m ? m[1] : null;
19   }
20 }
21 
22 /** Busca o usuário logado; retorna null se não houver */
23 export async function requireUser() {
24   const id = await getSessionUserId();
25   if (!id) return null;
26   const user = await prisma.user.findUnique({
27     where: { id },
28     select: { id: true, name: true, email: true }
29   });
30   return user;
31 }
32 
33 /** Apaga o cookie de sessão (async em Next 15) */
34 export async function clearSessionCookie() {
35   const c = await cookies();
36   c.set({
37     name: COOKIE_NAME,
38     value: "",
39     httpOnly: true,
40     path: "/",
41     maxAge: 0
42   });
43 }
44 
45 // === Access helpers (ClassAccess) ============================================
46 
47 /**
48  * Retorna o papel do usuário na turma (PROFESSOR | GESTOR) ou null se não tem acesso.
49  */
50 export async function getRole(userId: string, classId: string): Promise<ClassRole | null> {
51   try {
52     const row = await prisma.classAccess.findFirst({
53       where: { classId, userId },
54       select: { role: true },
55     });
56     return row?.role ?? null;
57   } catch (_e) {
58     return null;
59   }
60 }
61 
62 /** Versão que usa o usuário logado da sessão atual. */
63 export async function getMyRole(classId: string): Promise<ClassRole | null> {
64   const me = await requireUser();
65   if (!me) return null;
66   return getRole(me.id, classId);
67 }
68 
69 /** Açúcares para checagens rápidas na UI/rota. */
70 export function roleFlags(role: ClassRole | null) {
71   return {
72     isProfessor: role === "PROFESSOR",
73     isGestor: role === "GESTOR",
74     hasAccess: role === "PROFESSOR" || role === "GESTOR",
75   };
76 }

===== lib/prisma.ts =====
1 import { PrismaClient } from "@prisma/client";
2 
3 const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };
4 
5 export const prisma =
6   globalForPrisma.prisma ??
7   new PrismaClient({
8     log: ["error", "warn"],
9   });
10 
11 if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

===== middleware.ts =====
1 import { NextResponse } from "next/server";
2 import type { NextRequest } from "next/server";
3 
4 export function middleware(req: NextRequest) {
5   const path = req.nextUrl.pathname;
6 
7   // Corrige / (auth) /register e / (auth) /recover
8   if (path === "/(auth)/register") {
9     const url = req.nextUrl.clone();
10     url.pathname = "/register";
11     return NextResponse.redirect(url);
12   }
13   if (path === "/(auth)/recover") {
14     const url = req.nextUrl.clone();
15     url.pathname = "/recover-email";
16     return NextResponse.redirect(url);
17   }
18 
19   return NextResponse.next();
20 }
21 
22 export const config = {
23   matcher: ["/(auth)/register", "/(auth)/recover"]
24 };

===== next.config.mjs =====
1 /** next.config.mjs — PWA habilitado em produção + ignora ESLint/TS no build */
2 import withPWA from 'next-pwa';
3 
4 const isDev = process.env.NODE_ENV !== 'production';
5 
6 const withPwa = withPWA({
7   dest: 'public',
8   register: true,
9   skipWaiting: true,
10   disable: isDev,
11   fallbacks: { document: '/offline' },
12   // Ajustes finos de cache (opcional)
13   runtimeCaching: [
14     {
15       urlPattern: ({ request }) => request.destination === 'image',
16       handler: 'CacheFirst',
17       options: {
18         cacheName: 'images',
19         expiration: { maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 30 },
20       },
21     },
22     {
23       urlPattern: ({ request }) =>
24         ['style', 'script', 'font'].includes(request.destination),
25       handler: 'StaleWhileRevalidate',
26       options: { cacheName: 'assets' },
27     },
28   ],
29 });
30 
31 export default withPwa({
32   // 🔽 faz o Next NÃO barrar o build por lint/type errors
33   eslint: { ignoreDuringBuilds: true },
34   typescript: { ignoreBuildErrors: true },
35 });

===== package.json =====
1 {
2   "name": "educc",
3   "private": true,
4   "version": "0.1.0",
5   "type": "module",
6   "scripts": {
7     "dev": "next dev",
8     "build": "pnpm prisma:gen && pnpm prisma:deploy && next build",
9     "start": "next start",
10     "typecheck": "tsc --noEmit",
11     "prisma:gen": "prisma generate",
12     "prisma:deploy": "prisma migrate deploy",
13     "prisma:push": "prisma db push",
14     "prisma:studio": "prisma studio",
15     "postinstall": "prisma generate",
16     "icons": "tsx scripts/generate-icons.ts",
17     "lint": "eslint ."
18   },
19   "dependencies": {
20     "@prisma/client": "^6.17.1",
21     "bcryptjs": "^3.0.2",
22     "csv-parse": "^6.1.0",
23     "lucide-react": "^0.453.0",
24     "next": "15.0.0",
25     "next-pwa": "^5.6.0",
26     "pdf-lib": "^1.17.1",
27     "react": "19.0.0",
28     "react-dom": "19.0.0",
29     "zod": "^3.23.8"
30   },
31   "devDependencies": {
32     "@babel/core": "^7.28.4",
33     "@eslint/eslintrc": "^3.3.1",
34     "@tailwindcss/postcss": "4.1.14",
35     "@types/node": "^22.7.4",
36     "@types/react": "^19.0.0",
37     "babel-loader": "^10.0.0",
38     "eslint": "^9.37.0",
39     "eslint-config-next": "^15.5.4",
40     "prisma": "^6.17.1",
41     "sharp": "^0.34.4",
42     "tailwindcss": "4.1.14",
43     "tsx": "^4.20.6",
44     "typescript": "^5.6.3",
45     "xlsx": "^0.18.5"
46   },
47   "engines": {
48     "node": "^20"
49   },
50   "pnpm": {
51     "allowScripts": {
52       "@prisma/client": true,
53       "prisma": true,
54       "@tailwindcss/oxide": true,
55       "sharp": true
56     }
57   }
58 }

===== prisma/schema.prisma =====
1 generator client {
2   provider = "prisma-client-js"
3 }
4 
5 datasource db {
6   provider  = "postgresql"
7   url       = env("DATABASE_URL")
8   directUrl = env("DIRECT_URL")
9 }
10 
11 model User {
12   id           String   @id @default(cuid())
13   name         String
14   cpf          String   @unique
15   birthDate    DateTime
16   email        String   @unique
17   phone        String
18   createdAt    DateTime @default(now())
19   passwordHash String?
20 
21   resetTokens   PasswordResetToken[]
22   classes       Class[]              @relation("UserClasses")
23   // Back-relations adicionados automaticamente
24   classAccesses ClassAccess[]
25   shareLinks    ShareLink[]
26   auditLogs     AuditLog[]
27   groups        Group[]
28 }
29 
30 model PasswordResetToken {
31   id        String    @id @default(cuid())
32   token     String    @unique
33   userId    String
34   user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
35   expiresAt DateTime
36   usedAt    DateTime?
37   createdAt DateTime  @default(now())
38 }
39 
40 model Class {
41   id        String   @id @default(cuid())
42   name      String
43   ownerId   String
44   owner     User     @relation("UserClasses", fields: [ownerId], references: [id], onDelete: Cascade)
45   createdAt DateTime @default(now())
46 
47   attendances      Attendance[]
48   contents         Content[]
49   students         Student[]
50   // Back-relations adicionados automaticamente
51   accesses         ClassAccess[]
52   shareLinks       ShareLink[]
53   auditLogs        AuditLog[]
54   groupMemberships ClassGroupMembership[]
55 }
56 
57 model Attendance {
58   id         String    @id @default(cuid())
59   classId    String
60   cls        Class     @relation(fields: [classId], references: [id], onDelete: Cascade)
61   seq        Int
62   title      String    @default("Chamada")
63   createdAt  DateTime  @default(now())
64   lessonDate DateTime? // data editável da aula (UTC, opcional)
65 
66   @@unique([classId, seq])
67 }
68 
69 model Content {
70   id        String   @id @default(cuid())
71   classId   String
72   cls       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
73   seq       Int
74   title     String   @default("Conteúdo")
75   bodyHtml  String? // futuro: editor; por enquanto pode ficar vazio
76   createdAt DateTime @default(now())
77 
78   @@unique([classId, seq])
79 }
80 
81 model Student {
82   id        String   @id @default(cuid())
83   classId   String
84   cls       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
85   name      String
86   cpf       String?
87   contact   String? // whatsapp/email/telefone
88   createdAt DateTime @default(now())
89 }
90 
91 /// Marcações de presença por aluno em uma chamada específica (classId+seq).
92 
93 /// Marcações de presença por aluno em uma chamada específica (classId+seq).
94 model AttendancePresence {
95   id        String   @id @default(cuid())
96   classId   String
97   seq       Int
98   studentId String
99   present   Boolean  @default(false)
100   createdAt DateTime @default(now())
101   updatedAt DateTime @updatedAt
102 
103   // Sem relações Prisma para não exigir back-relations agora.
104   @@unique([classId, seq, studentId], name: "class_seq_student_unique")
105   @@index([classId, seq], name: "class_seq_idx")
106 }
107 
108 // ====== CONTROLE DE ACESSO / LINKS / AUDITORIA ======
109 
110 /// Papéis por turma:
111 /// - PROFESSOR: único por turma (garantido por índice único parcial na migração)
112 /// - GESTOR: ilimitado
113 enum ClassRole {
114   PROFESSOR
115   GESTOR
116 }
117 
118 /// Relação usuário ↔ turma com papel
119 model ClassAccess {
120   id        String    @id @default(cuid())
121   classId   String
122   userId    String
123   role      ClassRole
124   createdAt DateTime  @default(now())
125 
126   // Relations
127   cls  Class @relation(fields: [classId], references: [id], onDelete: Cascade)
128   user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
129 
130   // Um usuário não pode ter dois papéis simultâneos na mesma turma
131   @@unique([classId, userId], name: "class_user_unique")
132   @@index([classId])
133   @@index([userId])
134 }
135 
136 /// Link compartilhável para entrar na turma com um papel
137 model ShareLink {
138   id            String    @id @default(cuid())
139   classId       String
140   token         String    @unique
141   role          ClassRole
142   createdBy     String
143   isRevoked     Boolean   @default(false)
144   isPromotional Boolean   @default(false) // criador ainda professor -> 1º claim promove criador a GESTOR e dá PROF. ao convidado
145   usedAt        DateTime?
146   createdAt     DateTime  @default(now())
147 
148   // Relations
149   cls    Class @relation(fields: [classId], references: [id], onDelete: Cascade)
150   author User  @relation(fields: [createdBy], references: [id], onDelete: Cascade)
151 
152   @@index([classId])
153   @@index([createdBy])
154 }
155 
156 /// Auditoria de ações sensíveis
157 model AuditLog {
158   id        String   @id @default(cuid())
159   classId   String
160   actorId   String?
161   type      String // ex.: LINK_CREATED, LINK_CLAIMED, CLAIM_BLOCKED_PROFESSOR_EXISTS, ACCESS_REVOKED, CREATOR_PROMOTED
162   metadata  Json?
163   createdAt DateTime @default(now())
164 
165   cls   Class @relation(fields: [classId], references: [id], onDelete: Cascade)
166   actor User? @relation(fields: [actorId], references: [id], onDelete: SetNull)
167 
168   @@index([classId, createdAt])
169   @@index([actorId])
170 }
171 
172 model Group {
173   id        String   @id @default(cuid())
174   userId    String
175   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
176   name      String
177   createdAt DateTime @default(now())
178 
179   memberships ClassGroupMembership[]
180 
181   @@index([userId, createdAt])
182 }
183 
184 model ClassGroupMembership {
185   id        String   @id @default(cuid())
186   classId   String
187   groupId   String
188   createdAt DateTime @default(now())
189 
190   cls Class @relation(fields: [classId], references: [id], onDelete: Cascade)
191   grp Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
192 
193   @@unique([classId, groupId], name: "class_group_unique")
194   @@index([groupId])
195   @@index([classId])
196 }
