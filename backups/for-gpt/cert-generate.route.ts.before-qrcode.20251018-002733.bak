import { NextResponse } from "next/server";
import { PDFDocument, StandardFonts, rgb, PDFFont } from "pdf-lib";

export const dynamic = "force-dynamic";

type EventPayload = {
  id: string;
  nome: string;
  descricao?: string;
  data_inicio?: string;
  data_fim?: string;
  local?: string;
  cidade_uf?: string;
  carga_horaria?: string;
  responsavel?: string;
  // textos
  texto_participante?: string;
  texto_ministrante?: string;
  texto_organizador?: string;
  texto_verso?: string; // <<< agora suportado
  // assinaturas configuráveis
  sign1_name?: string; sign1_role?: string;
  sign2_name?: string; sign2_role?: string;
};
type Student = {
  aluno_nome: string;
  aluno_doc?: string;
  turma?: string;
  carga_horaria?: string;
  observacoes?: string;
};

/** quebra texto por palavras respeitando largura máxima */
function wrapTextByWidth({
  text,
  font,
  size,
  maxWidth,
}: { text: string; font: PDFFont; size: number; maxWidth: number }): string[] {
  const words = (text || "").trim().split(/\s+/);
  const lines: string[] = [];
  let line = "";

  for (const w of words) {
    const test = line ? line + " " + w : w;
    const width = font.widthOfTextAtSize(test, size);
    if (width <= maxWidth) {
      line = test;
    } else {
      if (line) lines.push(line);
      // palavra muito longa: quebra em pedaços
      if (font.widthOfTextAtSize(w, size) > maxWidth) {
        let chunk = "";
        for (const ch of w) {
          const t2 = chunk + ch;
          if (font.widthOfTextAtSize(t2, size) <= maxWidth) {
            chunk = t2;
          } else {
            if (chunk) lines.push(chunk);
            chunk = ch;
          }
        }
        line = chunk;
      } else {
        line = w;
      }
    }
  }
  if (line) lines.push(line);
  return lines;
}

/** centraliza texto */
function drawCenteredText(page: any, text: string, y: number, size: number, font: PDFFont, color = rgb(0,0,0)) {
  const { width } = page.getSize();
  const textWidth = font.widthOfTextAtSize(text, size);
  page.drawText(text, { x: (width - textWidth) / 2, y, size, font, color });
}

/** texto alinhado à direita com margem */
function drawRightAlignedText(page: any, text: string, y: number, size: number, font: PDFFont, rightMargin: number, color = rgb(0,0,0)) {
  const { width } = page.getSize();
  const textWidth = font.widthOfTextAtSize(text, size);
  const x = Math.max(0, width - rightMargin - textWidth);
  page.drawText(text, { x, y, size, font, color });
}

/** data pt-BR "19 de agosto de 2025" a partir de "YYYY-MM-DD" */
function formatPtBrDate(iso?: string): string | null {
  if (!iso) return null;
  const d = new Date(iso);
  if (isNaN(d.getTime())) return null;
  const fmt = new Intl.DateTimeFormat("pt-BR", { day: "2-digit", month: "long", year: "numeric" });
  const parts = fmt.formatToParts(d);
  const dia = parts.find(p => p.type === "day")?.value ?? "";
  const mes = parts.find(p => p.type === "month")?.value ?? "";
  const ano = parts.find(p => p.type === "year")?.value ?? "";
  return `${dia} de ${mes} de ${ano}`;
}

/** bloco de assinaturas (3 colunas) */
function drawSignaturesBlock(page: any, font: PDFFont, fontBold: PDFFont, opts: {
  y: number;
  leftMargin: number;
  rightMargin: number;
  titles: { name: string; role: string }[];
}) {
  const { width } = page.getSize();
  const { y, leftMargin, rightMargin, titles } = opts;
  const usableWidth = width - leftMargin - rightMargin;
  const cols = titles.length;
  const colW = usableWidth / cols;
  const lineY = y;
  const nameY = y - 14;
  const roleY = y - 28;

  for (let i = 0; i < cols; i++) {
    const x0 = leftMargin + i * colW + 10;
    const x1 = leftMargin + (i + 1) * colW - 10;
    page.drawLine({ start: { x: x0, y: lineY }, end: { x: x1, y: lineY }, thickness: 1, color: rgb(0,0,0) });
    const centerX = (x0 + x1) / 2;
    const nameSize = 10;
    const roleSize = 9;
    const name = titles[i].name;
    const role = titles[i].role;
    const nameWidth = fontBold.widthOfTextAtSize(name, nameSize);
    const roleWidth = font.widthOfTextAtSize(role, roleSize);
    page.drawText(name, { x: centerX - nameWidth / 2, y: nameY, size: nameSize, font: fontBold });
    page.drawText(role, { x: centerX - roleWidth / 2, y: roleY, size: roleSize, font });
  }
}

async function buildCertificatesPDF(ev: EventPayload, alunos: Student[]): Promise<Uint8Array> {
  const pdf = await PDFDocument.create();
  const font = await pdf.embedFont(StandardFonts.Helvetica);
  const fontBold = await pdf.embedFont(StandardFonts.HelveticaBold);

  const red = rgb(0.80, 0.00, 0.00);
  const green = rgb(0.00, 0.45, 0.30);
  const gray = rgb(0.25, 0.25, 0.25);

  // defaults de assinatura, se não vierem do formulário
  const s1name = (ev.sign1_name || "VÁGNER ESPÍNDOLA RODRIGUES").toUpperCase();
  const s1role = ev.sign1_role || "Prefeito Municipal";
  const s2name = (ev.sign2_name || "GEÓVANA BENEDET ZANETTE").toUpperCase();
  const s2role = ev.sign2_role || "Secretária Municipal de Educação";

  for (const st of alunos) {
    if (!st?.aluno_nome) continue;

    // === FRENTE ===
    const page = pdf.addPage([842, 595]); // A4 paisagem
    const { width, height } = page.getSize();

    const margin = 36;
    const left = margin;
    const right = margin;
    const contentX = left + 24;
    const contentWidth = width - (contentX + right + 24);
    let y = height - 72;

    // Moldura
    page.drawRectangle({
      x: margin / 2,
      y: margin / 2,
      width: width - margin,
      height: height - margin,
      borderColor: rgb(0.6, 0.6, 0.6),
      borderWidth: 0.8,
    });

    // Barras decorativas
    page.drawRectangle({ x: width - 140, y: height - 40, width: 140, height: 40, color: red });
    page.drawRectangle({ x: width - 95, y: height - 70, width: 95, height: 30, color: green });

    // Título
    drawCenteredText(page, "CERTIFICADO", y, 28, fontBold, red);
    y -= 44;

    // Linha com nome + doc
    const nomeLinha = [st.aluno_nome, st.aluno_doc ? `- ${st.aluno_doc}` : ""].filter(Boolean).join(" ");
    drawCenteredText(page, nomeLinha, y, 14, fontBold, rgb(0,0,0));
    y -= 28;

    // Texto do corpo
    const periodo =
      ev.data_inicio || ev.data_fim
        ? `${ev.data_inicio ?? ""}${ev.data_inicio && ev.data_fim ? " a " : ""}${ev.data_fim ?? ""}`
        : "";
    const carga = st.carga_horaria || ev.carga_horaria || "";

    // 1) Se veio texto_participante, processa códigos; senão usa modelo padrão
    let paragraph = ev.texto_participante?.trim();
    if (paragraph) {
      paragraph = paragraph
        .replace(/\[nome do participante\]/gi, st.aluno_nome)
        .replace(/\[cpf\]/gi, st.aluno_doc || "")
        .replace(/\[carga horária\]/gi, carga);
    } else {
      const partes: string[] = [];
      partes.push(`Certificamos que ${st.aluno_nome} participou do Curso "${(ev.nome || "Curso").toUpperCase()}",`);
      partes.push("promovido e organizado pela Escola Municipal de Governo de Criciúma,");
      if (periodo) partes.push(`realizado no período de ${periodo},`);
      if (carga)  partes.push(`com carga horária de ${carga}.`);
      paragraph = partes.join(" ");
    }

    const bodySize = 12.5;
    const bodyLH = 17;
    const bodyLines = wrapTextByWidth({ text: paragraph, font, size: bodySize, maxWidth: contentWidth });
    for (const line of bodyLines) {
      page.drawText(line, { x: contentX, y, size: bodySize, font, color: rgb(0,0,0) });
      y -= bodyLH;
    }

    // Espaço e data/lugar à direita
    y -= 20;
    const dataFormatada = formatPtBrDate(ev.data_fim || ev.data_inicio);
    const cidade = ev.cidade_uf?.trim() || ev.local?.trim();
    const linhaData = (cidade && dataFormatada) ? `${cidade}, ${dataFormatada}.` : (dataFormatada ? `${dataFormatada}.` : "");
    if (linhaData) {
      drawRightAlignedText(page, linhaData, y, 12, font, right, gray);
      y -= 28;
    }

    // Assinaturas (3 colunas): S1, S2, Participante
    const signY = 120;
    drawSignaturesBlock(page, font, fontBold, {
      y: signY,
      leftMargin: left,
      rightMargin: right,
      titles: [
        { name: s1name, role: s1role },
        { name: s2name, role: s2role },
        { name: (st.aluno_nome || "Participante").toUpperCase(), role: "Participante" },
      ],
    });

    // === VERSO (opcional) ===
    if (ev.texto_verso && ev.texto_verso.trim().length > 0) {
      const page2 = pdf.addPage([842, 595]); // mesma orientação
      const { width: w2, height: h2 } = page2.getSize();
      const m2 = 36;
      const left2 = m2;
      const right2 = m2;
      const contentX2 = left2 + 24;
      const contentW2 = w2 - (contentX2 + right2 + 24);
      let y2 = h2 - 64;

      // moldura leve no verso
      page2.drawRectangle({
        x: m2 / 2,
        y: m2 / 2,
        width: w2 - m2,
        height: h2 - m2,
        borderColor: rgb(0.75, 0.75, 0.75),
        borderWidth: 0.6,
      });

      // título do verso
      drawCenteredText(page2, "INFORMAÇÕES COMPLEMENTARES", y2, 16, fontBold, rgb(0,0,0));
      y2 -= 28;

      // texto do verso (aceita listas, parágrafos, etc. — aqui tratamos apenas como parágrafo corrido)
      const vText = ev.texto_verso.trim();
      const vSize = 12;
      const vLH = 16;
      const vLines = wrapTextByWidth({ text: vText, font, size: vSize, maxWidth: contentW2 });
      for (const line of vLines) {
        page2.drawText(line, { x: contentX2, y: y2, size: vSize, font, color: rgb(0,0,0) });
        y2 -= vLH;
        if (y2 < 64) {
          // adiciona nova página de verso se estourar
          const cont = pdf.addPage([842, 595]);
          y2 = h2 - 64;
          cont.drawRectangle({
            x: m2 / 2,
            y: m2 / 2,
            width: w2 - m2,
            height: h2 - m2,
            borderColor: rgb(0.75, 0.75, 0.75),
            borderWidth: 0.6,
          });
          // reescreve o restante das linhas nesta nova página
          page2.drawText("", { x: 0, y: 0, size: 1, font }); // no-op para evitar lint
        }
      }
    }
  }

  return await pdf.save();
}

export async function POST(req: Request, { params }: { params: { id: string } }) {
  try {
    const body = await req.json().catch(() => ({}));
    const ev: EventPayload = body?.event;
    const alunos: Student[] = body?.students || [];

    if (!ev?.id || ev.id !== params.id) {
      return NextResponse.json({ ok: false, error: "Evento inválido" }, { status: 400 });
    }
    if (!ev?.nome) {
      return NextResponse.json({ ok: false, error: "Nome do evento é obrigatório" }, { status: 400 });
    }
    const validos = Array.isArray(alunos) ? alunos.filter((a) => a?.aluno_nome) : [];
    if (validos.length === 0) {
      return NextResponse.json({ ok: false, error: "Nenhum aluno válido fornecido" }, { status: 400 });
    }

    const pdfBytes = await buildCertificatesPDF(ev, validos);

    return new NextResponse(pdfBytes, {
      status: 200,
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="certificados-${params.id}.pdf"`,
        "Cache-Control": "no-store",
      },
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Falha ao gerar certificados" }, { status: 500 });
  }
}
